"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkaff_web"] = self["webpackChunkaff_web"] || []).push([["output_abap_cl_sxml_string_reader_clas_locals_mjs"],{

/***/ "./output_abap/cl_sxml_string_reader.clas.locals.mjs":
/*!***********************************************************!*\
  !*** ./output_abap/cl_sxml_string_reader.clas.locals.mjs ***!
  \***********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lcl_attribute\": () => (/* binding */ lcl_attribute),\n/* harmony export */   \"lcl_close_node\": () => (/* binding */ lcl_close_node),\n/* harmony export */   \"lcl_json_parser\": () => (/* binding */ lcl_json_parser),\n/* harmony export */   \"lcl_open_node\": () => (/* binding */ lcl_open_node),\n/* harmony export */   \"lcl_reader\": () => (/* binding */ lcl_reader),\n/* harmony export */   \"lcl_value_node\": () => (/* binding */ lcl_value_node)\n/* harmony export */ });\nconst {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ \"./output_abap/cx_root.clas.mjs\"));\r\n// cl_sxml_string_reader.clas.locals_imp.abap\r\nclass lcl_json_parser {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mt_nodes = new abap.types.Table(new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_json_parser=>ty_nodes\");\r\n    return this;\r\n  }\r\n  async parse(INPUT) {\r\n    let rt_nodes = new abap.types.Table(new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_json_parser=>ty_nodes\");\r\n    let iv_json = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\r\n    abap.statements.clear(this.mt_nodes);\r\n    await this.traverse({iv_json: iv_json});\r\n    rt_nodes.set(this.mt_nodes);\r\n    return rt_nodes;\r\n  }\r\n  async append(INPUT) {\r\n    let iv_type = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\r\n    if (INPUT && INPUT.iv_type) {iv_type.set(INPUT.iv_type);}\r\n    let iv_name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_name) {iv_name.set(INPUT.iv_name);}\r\n    let iv_key = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\r\n    let iv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_value) {iv_value.set(INPUT.iv_value);}\r\n    let ls_node = new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\");\r\n    ls_node.get().type.set(iv_type);\r\n    ls_node.get().name.set(iv_name);\r\n    ls_node.get().key.set(iv_key);\r\n    ls_node.get().value.set(iv_value);\r\n    abap.statements.append({source: ls_node, target: this.mt_nodes});\r\n  }\r\n  async traverse(INPUT) {\r\n    let iv_json = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\r\n    let iv_key = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\r\n    let lv_type = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let lv_error = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\r\n    let lv_error_message = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let lv_xml_offset = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let parsed;\r\n    try {\r\n        parsed = JSON.parse(iv_json.get());\r\n    } catch(e) {\r\n        lv_error_message.set(e.message);\r\n        lv_error.set(\"X\")\r\n    }\r\n    if (abap.compare.eq(lv_error, abap.builtin.abap_true)) {\r\n      abap.statements.find(lv_error_message, {regex: new abap.types.Character(15).set(' position (\\\\d+)'), submatches: [lv_xml_offset]});\r\n      throw await (new abap.Classes['CX_SXML_PARSE_ERROR']()).constructor_({xml_offset: lv_xml_offset});\r\n    }\r\n    lv_type.set(Array.isArray(parsed) ? \"array\" : typeof parsed);\r\n    if (parsed === null) lv_type.set(\"null\");\r\n    let unique153 = lv_type;\r\n    if (abap.compare.eq(unique153, new abap.types.Character(6).set('object'))) {\r\n      await this.traverse_object({iv_json: iv_json, iv_key: iv_key});\r\n    } else if (abap.compare.eq(unique153, new abap.types.Character(5).set('array'))) {\r\n      await this.traverse_array({iv_json: iv_json, iv_key: iv_key});\r\n    } else if (abap.compare.eq(unique153, new abap.types.Character(6).set('string')) || abap.compare.eq(unique153, new abap.types.Character(7).set('boolean')) || abap.compare.eq(unique153, new abap.types.Character(6).set('number')) || abap.compare.eq(unique153, new abap.types.Character(4).set('null'))) {\r\n      await this.traverse_basic({iv_json: iv_json, iv_key: iv_key});\r\n    } else {\r\n      abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(2), new abap.types.Character(4).set('todo')));\r\n    }\r\n  }\r\n  async traverse_basic(INPUT) {\r\n    let iv_json = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\r\n    let iv_key = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\r\n    let lv_type = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let parsed = JSON.parse(iv_json.get());\r\n    lv_type.set(typeof parsed);\r\n    if (parsed === null) lv_type.set(\"null\");\r\n    let unique154 = lv_type;\r\n    if (abap.compare.eq(unique154, new abap.types.Character(6).set('string'))) {\r\n      lv_type.set(new abap.types.Character(3).set('str'));\r\n    } else if (abap.compare.eq(unique154, new abap.types.Character(6).set('number'))) {\r\n      lv_type.set(new abap.types.Character(3).set('num'));\r\n    } else if (abap.compare.eq(unique154, new abap.types.Character(7).set('boolean'))) {\r\n      lv_type.set(new abap.types.Character(4).set('bool'));\r\n    }\r\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open, iv_name: lv_type, iv_key: iv_key});\r\n    if (abap.compare.ne(lv_type, new abap.types.Character(4).set('null'))) {\r\n      if (abap.compare.eq(lv_type, new abap.types.Character(3).set('str'))) {\r\n        await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value, iv_value: abap.builtin.substring({val: iv_json, off: new abap.types.Integer().set(1), len: abap.operators.minus(abap.builtin.strlen({val: iv_json}),new abap.types.Integer().set(2))})});\r\n      } else {\r\n        await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value, iv_value: iv_json});\r\n      }\r\n    }\r\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close, iv_name: lv_type});\r\n  }\r\n  async traverse_array(INPUT) {\r\n    let iv_json = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\r\n    let iv_key = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\r\n    let lv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let lv_length = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let lv_index = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let parsed = JSON.parse(iv_json.get());\r\n    lv_length.set(parsed.length);\r\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open, iv_name: new abap.types.Character(5).set('array'), iv_key: iv_key});\r\n    const indexBackup1 = abap.builtin.sy.get().index.get();\r\n    const unique155 = lv_length.get();\r\n    for (let unique156 = 0; unique156 < unique155; unique156++) {\r\n      abap.builtin.sy.get().index.set(unique156 + 1);\r\n      lv_index.set(abap.operators.minus(abap.builtin.sy.get().index,new abap.types.Integer().set(1)));\r\n      lv_value.set(JSON.stringify(parsed[lv_index.get()]));\r\n      await this.traverse({iv_json: lv_value});\r\n    }\r\n    abap.builtin.sy.get().index.set(indexBackup1);\r\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close, iv_name: new abap.types.Character(5).set('array')});\r\n  }\r\n  async traverse_object(INPUT) {\r\n    let iv_json = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\r\n    let iv_key = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\r\n    let lt_keys = new abap.types.Table(new abap.types.String({qualifiedName: \"STRING\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"\");\r\n    let lv_key = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let lv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let parsed = JSON.parse(iv_json.get());\r\n    Object.keys(parsed).forEach(k => lt_keys.append(k));\r\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open, iv_name: new abap.types.Character(6).set('object'), iv_key: iv_key});\r\n    for await (const unique157 of abap.statements.loop(lt_keys)) {\r\n      lv_key.set(unique157);\r\n      lv_value.set(JSON.stringify(parsed[lv_key.get()]));\r\n      await this.traverse({iv_json: lv_value, iv_key: lv_key});\r\n    }\r\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close, iv_name: new abap.types.Character(6).set('object')});\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_JSON_PARSER'] = lcl_json_parser;\r\nlcl_json_parser.ty_node = new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\");\r\nlcl_json_parser.ty_nodes = new abap.types.Table(new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_json_parser=>ty_nodes\");\r\nclass lcl_attribute {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_SXML_ATTRIBUTE\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    this.if_sxml_attribute$qname = new abap.types.Structure({\"name\": new abap.types.String({qualifiedName: \"STRING\"})});\r\n    this.if_sxml_attribute$value_type = new abap.types.Integer({qualifiedName: \"IF_SXML_VALUE=>VALUE_TYPE\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\r\n    let value_type = new abap.types.Integer({qualifiedName: \"IF_SXML_VALUE=>VALUE_TYPE\"});\r\n    if (INPUT && INPUT.value_type) {value_type.set(INPUT.value_type);}\r\n    this.if_sxml_attribute$qname.get().name.set(name);\r\n    this.if_sxml_attribute$value_type.set(value_type);\r\n    this.mv_value.set(value);\r\n    return this;\r\n  }\r\n  async if_sxml_attribute$get_value() {\r\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    value.set(this.mv_value);\r\n    return value;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_ATTRIBUTE'] = lcl_attribute;\r\nclass lcl_open_node {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_SXML_OPEN_ELEMENT\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mt_attributes = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"if_sxml_attribute=>attributes\");\r\n    this.if_sxml_open_element$qname = new abap.types.Structure({\"name\": new abap.types.String({qualifiedName: \"STRING\"})});\r\n    this.if_sxml_node$type = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let attributes = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"if_sxml_attribute=>attributes\");\r\n    if (INPUT && INPUT.attributes) {attributes.set(INPUT.attributes);}\r\n    this.if_sxml_node$type.set(abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open);\r\n    this.if_sxml_open_element$qname.get().name.set(name);\r\n    this.mt_attributes.set(attributes);\r\n    return this;\r\n  }\r\n  async if_sxml_open_element$get_attributes() {\r\n    let attr = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"if_sxml_attribute=>attributes\");\r\n    attr.set(this.mt_attributes);\r\n    return attr;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_OPEN_NODE'] = lcl_open_node;\r\nclass lcl_close_node {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_SXML_CLOSE_ELEMENT\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.if_sxml_close_element$qname = new abap.types.Structure({\"name\": new abap.types.String({qualifiedName: \"STRING\"})});\r\n    this.if_sxml_node$type = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    this.if_sxml_node$type.set(abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close);\r\n    this.if_sxml_close_element$qname.get().name.set(name);\r\n    return this;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_CLOSE_NODE'] = lcl_close_node;\r\nclass lcl_value_node {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_SXML_VALUE_NODE\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    this.if_sxml_node$type = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\r\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\r\n    this.if_sxml_node$type.set(abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value);\r\n    this.mv_value.set(value);\r\n    return this;\r\n  }\r\n  async if_sxml_value_node$get_value() {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    val.set(this.mv_value);\r\n    return val;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_VALUE_NODE'] = lcl_value_node;\r\nclass lcl_reader {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_SXML_READER\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mv_json = new abap.types.String({qualifiedName: \"STRING\"});\r\n    this.mt_nodes = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_reader=>ty_nodes\");\r\n    this.mv_pointer = new abap.types.Integer({qualifiedName: \"I\"});\r\n    this.if_sxml_reader$node_type = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\r\n    this.if_sxml_reader$name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    this.if_sxml_reader$value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let iv_json = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\r\n    this.mv_json.set(iv_json);\r\n    return this;\r\n  }\r\n  async initialize() {\r\n    let lo_json = new abap.types.ABAPObject({qualifiedName: \"LCL_JSON_PARSER\"});\r\n    let lt_parsed = new abap.types.Table(new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_json_parser=>ty_nodes\");\r\n    let ls_parsed = new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\");\r\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\"});\r\n    let lt_attributes = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"if_sxml_attribute=>attributes\");\r\n    let li_attribute = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\"});\r\n    if (abap.compare.initial(this.mv_json)) {\r\n      return;\r\n    }\r\n    lo_json.set(await (new abap.Classes['CLAS-CL_SXML_STRING_READER-LCL_JSON_PARSER']()).constructor_());\r\n    lt_parsed.set((await lo_json.get().parse({iv_json: this.mv_json})));\r\n    for await (const unique158 of abap.statements.loop(lt_parsed)) {\r\n      ls_parsed.set(unique158);\r\n      let unique159 = ls_parsed.get().type;\r\n      if (abap.compare.eq(unique159, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open)) {\r\n        abap.statements.clear(lt_attributes);\r\n        if (abap.compare.initial(ls_parsed.get().key) === false) {\r\n          li_attribute.set(await (new abap.Classes['CLAS-CL_SXML_STRING_READER-LCL_ATTRIBUTE']()).constructor_({name: new abap.types.Character(4).set('name'), value: ls_parsed.get().key, value_type: abap.Classes['IF_SXML_VALUE'].if_sxml_value$co_vt_text}));\r\n          abap.statements.append({source: li_attribute, target: lt_attributes});\r\n        }\r\n        li_node.set(await (new abap.Classes['CLAS-CL_SXML_STRING_READER-LCL_OPEN_NODE']()).constructor_({name: ls_parsed.get().name, attributes: lt_attributes}));\r\n      } else if (abap.compare.eq(unique159, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close)) {\r\n        li_node.set(await (new abap.Classes['CLAS-CL_SXML_STRING_READER-LCL_CLOSE_NODE']()).constructor_({name: ls_parsed.get().name}));\r\n      } else if (abap.compare.eq(unique159, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value)) {\r\n        li_node.set(await (new abap.Classes['CLAS-CL_SXML_STRING_READER-LCL_VALUE_NODE']()).constructor_({value: ls_parsed.get().value}));\r\n      } else {\r\n        abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Integer().set(2)));\r\n      }\r\n      abap.statements.append({source: li_node, target: this.mt_nodes});\r\n    }\r\n    abap.statements.clear(this.mv_json);\r\n    this.mv_pointer.set(new abap.types.Integer().set(1));\r\n  }\r\n  async if_sxml_reader$next_attribute(INPUT) {\r\n    let value_type = new abap.types.Integer({qualifiedName: \"IF_SXML_VALUE=>VALUE_TYPE\"});\r\n    if (INPUT && INPUT.value_type) {value_type.set(INPUT.value_type);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n  }\r\n  async if_sxml_reader$next_node(INPUT) {\r\n    let value_type = new abap.types.Integer({qualifiedName: \"IF_SXML_VALUE=>VALUE_TYPE\"});\r\n    if (INPUT && INPUT.value_type) {value_type.set(INPUT.value_type);}\r\n    if (INPUT === undefined || INPUT.value_type === undefined) {value_type = abap.Classes['IF_SXML_VALUE'].co_vt_text;}\r\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\"});\r\n    let open = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_OPEN_ELEMENT\"});\r\n    let close = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_CLOSE_ELEMENT\"});\r\n    let value = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_VALUE_NODE\"});\r\n    await this.initialize();\r\n    abap.statements.readTable(this.mt_nodes,{index: this.mv_pointer,into: node});\r\n    this.mv_pointer.set(abap.operators.add(this.mv_pointer,new abap.types.Integer().set(1)));\r\n    this.if_sxml_reader$node_type.set(node.get().if_sxml_node$type);\r\n    abap.statements.clear(this.if_sxml_reader$name);\r\n    let unique160 = this.if_sxml_reader$node_type;\r\n    if (abap.compare.eq(unique160, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open)) {\r\n      await abap.statements.cast(open, node);\r\n      this.if_sxml_reader$name.set(open.get().if_sxml_open_element$qname.get().name);\r\n    } else if (abap.compare.eq(unique160, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close)) {\r\n      await abap.statements.cast(close, node);\r\n      this.if_sxml_reader$name.set(close.get().if_sxml_close_element$qname.get().name);\r\n    }\r\n  }\r\n  async if_sxml_reader$skip_node(INPUT) {\r\n    let writer = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_WRITER\"});\r\n    if (INPUT && INPUT.writer) {writer.set(INPUT.writer);}\r\n  }\r\n  async if_sxml_reader$read_next_node() {\r\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\"});\r\n    await this.initialize();\r\n    abap.statements.readTable(this.mt_nodes,{index: this.mv_pointer,into: node});\r\n    this.mv_pointer.set(abap.operators.add(this.mv_pointer,new abap.types.Integer().set(1)));\r\n    return node;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_READER'] = lcl_reader;\r\nlcl_reader.ty_nodes = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_reader=>ty_nodes\");\r\n\r\n//# sourceMappingURL=cl_sxml_string_reader.clas.locals.mjs.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://aff-web/./output_abap/cl_sxml_string_reader.clas.locals.mjs?");

/***/ })

}]);