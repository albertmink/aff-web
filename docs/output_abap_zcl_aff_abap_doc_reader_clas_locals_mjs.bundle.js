"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkaff_web"] = self["webpackChunkaff_web"] || []).push([["output_abap_zcl_aff_abap_doc_reader_clas_locals_mjs"],{

/***/ "./output_abap/zcl_aff_abap_doc_reader.clas.locals.mjs":
/*!*************************************************************!*\
  !*** ./output_abap/zcl_aff_abap_doc_reader.clas.locals.mjs ***!
  \*************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lcl_section_source_comments\": () => (/* binding */ lcl_section_source_comments)\n/* harmony export */ });\nconst {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ \"./output_abap/cx_root.clas.mjs\"));\r\n// zcl_aff_abap_doc_reader.clas.locals_def.abap\r\n// zcl_aff_abap_doc_reader.clas.locals_imp.abap\r\nclass lcl_section_source_comments {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.clsname = new abap.types.String({qualifiedName: \"STRING\"});\r\n    this.depth = new abap.types.Integer({qualifiedName: \"I\"});\r\n    this.hierarchy_nodes = new abap.types.Table(new abap.types.Structure({\"depth\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-DEPTH\"}), \"node_name\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-NODE_NAME\"}), \"parent_node\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-PARENT_NODE\"}), \"stmnt_from_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_FROM_IDX\"}), \"stmnt_to_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_TO_IDX\"})}, \"lcl_section_source_comments=>ty_node\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_nodes\");\r\n    return this;\r\n  }\r\n  async is_within_data_begin_end_of(INPUT) {\r\n    let result = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\r\n    let tab_statements = new abap.types.Table(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_sstmnt\");\r\n    if (INPUT && INPUT.tab_statements) {tab_statements.set(INPUT.tab_statements);}\r\n    let tab_tokens = new abap.types.Table(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_stokesx\");\r\n    if (INPUT && INPUT.tab_tokens) {tab_tokens.set(INPUT.tab_tokens);}\r\n    let limit = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (INPUT && INPUT.limit) {limit.set(INPUT.limit);}\r\n    let limit_col = new abap.types.Integer({qualifiedName: \"INT2\"});\r\n    if (INPUT && INPUT.limit_col) {limit_col.set(INPUT.limit_col);}\r\n    let fs_fs_tok_prev_prev_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_tok_prev_prev2_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_tok_prev_prev1_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_stmnt_tmp_ = new abap.types.FieldSymbol(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"));\r\n    let counter_begin_of = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let counter_end_of = new abap.types.Integer({qualifiedName: \"I\"});\r\n    result.set(abap.builtin.abap_false);\r\n    abap.statements.clear(this.me.get().depth);\r\n    if (abap.compare.gt(limit_col, new abap.types.Integer().set(0))) {\r\n      for await (const unique17 of abap.statements.loop(tab_statements,{where: async (I) => {return (abap.compare.ne(I.type, new abap.types.Character(1).set('P')) && abap.compare.ne(I.type, new abap.types.Character(1).set('S')) && abap.compare.ne(I.type, new abap.types.Character(1).set('G'))) && abap.compare.le(I.from, limit);}})) {\r\n        fs_fs_stmnt_tmp_.assign(unique17);\r\n        abap.statements.readTable(tab_tokens,{index: fs_fs_stmnt_tmp_.get().from,assigning: fs_fs_tok_prev_prev_});\r\n        abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_tmp_.get().from,new abap.types.Integer().set(1)),assigning: fs_fs_tok_prev_prev1_});\r\n        abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_tmp_.get().from,new abap.types.Integer().set(2)),assigning: fs_fs_tok_prev_prev2_});\r\n        if (((abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(4).set('DATA')) || abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(10).set('CLASS-DATA')) || abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(9).set('CONSTANTS'))) && abap.compare.eq(fs_fs_tok_prev_prev1_.get().str, new abap.types.Character(5).set('BEGIN')) && abap.compare.eq(fs_fs_tok_prev_prev2_.get().str, new abap.types.Character(2).set('OF')))) {\r\n          counter_begin_of.set(abap.operators.add(counter_begin_of,new abap.types.Integer().set(1)));\r\n          this.me.get().depth.set(abap.operators.add(this.me.get().depth,new abap.types.Integer().set(1)));\r\n        } else if (((abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(4).set('DATA')) || abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(10).set('CLASS-DATA')) || abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(9).set('CONSTANTS'))) && abap.compare.eq(fs_fs_tok_prev_prev1_.get().str, new abap.types.Character(3).set('END')) && abap.compare.eq(fs_fs_tok_prev_prev2_.get().str, new abap.types.Character(2).set('OF')))) {\r\n          counter_end_of.set(abap.operators.add(counter_end_of,new abap.types.Integer().set(1)));\r\n          this.me.get().depth.set(abap.operators.minus(this.me.get().depth,new abap.types.Integer().set(1)));\r\n        }\r\n      }\r\n    } else {\r\n      for await (const unique18 of abap.statements.loop(tab_statements,{where: async (I) => {return (abap.compare.ne(I.type, new abap.types.Character(1).set('P')) && abap.compare.ne(I.type, new abap.types.Character(1).set('S')) && abap.compare.ne(I.type, new abap.types.Character(1).set('G'))) && abap.compare.lt(I.from, limit);}})) {\r\n        fs_fs_stmnt_tmp_.assign(unique18);\r\n        abap.statements.readTable(tab_tokens,{index: fs_fs_stmnt_tmp_.get().from,assigning: fs_fs_tok_prev_prev_});\r\n        abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_tmp_.get().from,new abap.types.Integer().set(1)),assigning: fs_fs_tok_prev_prev1_});\r\n        abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_tmp_.get().from,new abap.types.Integer().set(2)),assigning: fs_fs_tok_prev_prev2_});\r\n        if (((abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(4).set('DATA')) || abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(10).set('CLASS-DATA')) || abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(9).set('CONSTANTS'))) && abap.compare.eq(fs_fs_tok_prev_prev1_.get().str, new abap.types.Character(5).set('BEGIN')) && abap.compare.eq(fs_fs_tok_prev_prev2_.get().str, new abap.types.Character(2).set('OF')))) {\r\n          counter_begin_of.set(abap.operators.add(counter_begin_of,new abap.types.Integer().set(1)));\r\n          this.me.get().depth.set(abap.operators.add(this.me.get().depth,new abap.types.Integer().set(1)));\r\n        } else if (((abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(4).set('DATA')) || abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(10).set('CLASS-DATA')) || abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(9).set('CONSTANTS'))) && abap.compare.eq(fs_fs_tok_prev_prev1_.get().str, new abap.types.Character(3).set('END')) && abap.compare.eq(fs_fs_tok_prev_prev2_.get().str, new abap.types.Character(2).set('OF')))) {\r\n          counter_end_of.set(abap.operators.add(counter_end_of,new abap.types.Integer().set(1)));\r\n          this.me.get().depth.set(abap.operators.minus(this.me.get().depth,new abap.types.Integer().set(1)));\r\n        }\r\n      }\r\n    }\r\n    if (abap.compare.gt(counter_begin_of, counter_end_of)) {\r\n      result.set(abap.builtin.abap_true);\r\n    }\r\n    return result;\r\n  }\r\n  async is_within_types_begin_end_of(INPUT) {\r\n    let result = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\r\n    let tab_statements = new abap.types.Table(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_sstmnt\");\r\n    if (INPUT && INPUT.tab_statements) {tab_statements.set(INPUT.tab_statements);}\r\n    let tab_tokens = new abap.types.Table(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_stokesx\");\r\n    if (INPUT && INPUT.tab_tokens) {tab_tokens.set(INPUT.tab_tokens);}\r\n    let limit = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (INPUT && INPUT.limit) {limit.set(INPUT.limit);}\r\n    let limit_col = new abap.types.Integer({qualifiedName: \"INT2\"});\r\n    if (INPUT && INPUT.limit_col) {limit_col.set(INPUT.limit_col);}\r\n    let fs_fs_tok_prev_prev_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_tok_prev_prev2_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_tok_prev_prev1_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_stmnt_tmp_ = new abap.types.FieldSymbol(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"));\r\n    let counter_begin_of = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let counter_end_of = new abap.types.Integer({qualifiedName: \"I\"});\r\n    result.set(abap.builtin.abap_false);\r\n    abap.statements.clear(this.me.get().depth);\r\n    if (abap.compare.gt(limit_col, new abap.types.Integer().set(0))) {\r\n      for await (const unique19 of abap.statements.loop(tab_statements,{where: async (I) => {return (abap.compare.ne(I.type, new abap.types.Character(1).set('P')) && abap.compare.ne(I.type, new abap.types.Character(1).set('S')) && abap.compare.ne(I.type, new abap.types.Character(1).set('G'))) && abap.compare.le(I.from, limit);}})) {\r\n        fs_fs_stmnt_tmp_.assign(unique19);\r\n        abap.statements.readTable(tab_tokens,{index: fs_fs_stmnt_tmp_.get().from,assigning: fs_fs_tok_prev_prev_});\r\n        abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_tmp_.get().from,new abap.types.Integer().set(1)),assigning: fs_fs_tok_prev_prev1_});\r\n        abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_tmp_.get().from,new abap.types.Integer().set(2)),assigning: fs_fs_tok_prev_prev2_});\r\n        if ((abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(5).set('TYPES')) && abap.compare.eq(fs_fs_tok_prev_prev1_.get().str, new abap.types.Character(5).set('BEGIN')) && abap.compare.eq(fs_fs_tok_prev_prev2_.get().str, new abap.types.Character(2).set('OF')))) {\r\n          counter_begin_of.set(abap.operators.add(counter_begin_of,new abap.types.Integer().set(1)));\r\n          this.me.get().depth.set(abap.operators.add(this.me.get().depth,new abap.types.Integer().set(1)));\r\n        } else if ((abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(5).set('TYPES')) && abap.compare.eq(fs_fs_tok_prev_prev1_.get().str, new abap.types.Character(3).set('END')) && abap.compare.eq(fs_fs_tok_prev_prev2_.get().str, new abap.types.Character(2).set('OF')))) {\r\n          counter_end_of.set(abap.operators.add(counter_end_of,new abap.types.Integer().set(1)));\r\n          this.me.get().depth.set(abap.operators.minus(this.me.get().depth,new abap.types.Integer().set(1)));\r\n        }\r\n      }\r\n    } else {\r\n      for await (const unique20 of abap.statements.loop(tab_statements,{where: async (I) => {return (abap.compare.ne(I.type, new abap.types.Character(1).set('P')) && abap.compare.ne(I.type, new abap.types.Character(1).set('S')) && abap.compare.ne(I.type, new abap.types.Character(1).set('G'))) && abap.compare.lt(I.from, limit);}})) {\r\n        fs_fs_stmnt_tmp_.assign(unique20);\r\n        abap.statements.readTable(tab_tokens,{index: fs_fs_stmnt_tmp_.get().from,assigning: fs_fs_tok_prev_prev_});\r\n        abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_tmp_.get().from,new abap.types.Integer().set(1)),assigning: fs_fs_tok_prev_prev1_});\r\n        abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_tmp_.get().from,new abap.types.Integer().set(2)),assigning: fs_fs_tok_prev_prev2_});\r\n        if ((abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(5).set('TYPES')) && abap.compare.eq(fs_fs_tok_prev_prev1_.get().str, new abap.types.Character(5).set('BEGIN')) && abap.compare.eq(fs_fs_tok_prev_prev2_.get().str, new abap.types.Character(2).set('OF')))) {\r\n          counter_begin_of.set(abap.operators.add(counter_begin_of,new abap.types.Integer().set(1)));\r\n          this.me.get().depth.set(abap.operators.add(this.me.get().depth,new abap.types.Integer().set(1)));\r\n        } else if ((abap.compare.eq(fs_fs_tok_prev_prev_.get().str, new abap.types.Character(5).set('TYPES')) && abap.compare.eq(fs_fs_tok_prev_prev1_.get().str, new abap.types.Character(3).set('END')) && abap.compare.eq(fs_fs_tok_prev_prev2_.get().str, new abap.types.Character(2).set('OF')))) {\r\n          counter_end_of.set(abap.operators.add(counter_end_of,new abap.types.Integer().set(1)));\r\n          this.me.get().depth.set(abap.operators.minus(this.me.get().depth,new abap.types.Integer().set(1)));\r\n        }\r\n      }\r\n    }\r\n    if (abap.compare.gt(counter_begin_of, counter_end_of)) {\r\n      result.set(abap.builtin.abap_true);\r\n    }\r\n    return result;\r\n  }\r\n  async scan_code(INPUT) {\r\n    let source_to_be_scanned = new abap.types.Table(new abap.types.String(), {\"withHeader\":false}, \"STRING_TABLE\");\r\n    if (INPUT && INPUT.source_to_be_scanned) {source_to_be_scanned.set(INPUT.source_to_be_scanned);}\r\n    let tab_statements = new abap.types.Table(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_sstmnt\");\r\n    if (INPUT && INPUT.tab_statements) {tab_statements = INPUT.tab_statements;}\r\n    let tab_tokens = new abap.types.Table(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_stokesx\");\r\n    if (INPUT && INPUT.tab_tokens) {tab_tokens = INPUT.tab_tokens;}\r\n    if (abap.Classes['KERNEL_SCAN_ABAP_SOURCE'] === undefined) throw new Error(\"ScanAbapSource, kernel class missing\");\r\n    await abap.Classes['KERNEL_SCAN_ABAP_SOURCE'].call({scan_abap_source: source_to_be_scanned, tokens_into: tab_tokens, statements_into: tab_statements, with_analysis: true, with_comments: true, with_pragmas: new abap.types.Character(1).set('*')});\r\n  }\r\n  async identify_abap_doc_blocks_all(INPUT) {\r\n    let tab_abap_doc = new abap.types.Table(new abap.types.Structure({\"tab_comments\": new abap.types.Table(new abap.types.String(), {\"withHeader\":false}, \"STRING_TABLE\"), \"column_first_comment\": new abap.types.Integer({qualifiedName: \"TY_COMMENT_BLOCK-COLUMN_FIRST_COMMENT\"}), \"hook_relevant_tok_type\": new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), \"hook_relevant_tok_name\": new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), \"hook_relevant_tok_name_add\": new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), \"hook_relevant_tok_type_stmnt\": new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), \"hook_relevant_tok_name_stmnt\": new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\")}, \"ty_comment_block\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"ty_comment_blocks\");\r\n    let tab_statements = new abap.types.Table(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_sstmnt\");\r\n    if (INPUT && INPUT.tab_statements) {tab_statements.set(INPUT.tab_statements);}\r\n    let tab_tokens = new abap.types.Table(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_stokesx\");\r\n    if (INPUT && INPUT.tab_tokens) {tab_tokens.set(INPUT.tab_tokens);}\r\n    let tab_source = new abap.types.Table(new abap.types.String(), {\"withHeader\":false}, \"STRING_TABLE\");\r\n    if (INPUT && INPUT.tab_source) {tab_source.set(INPUT.tab_source);}\r\n    let l_node = new abap.types.Structure({\"depth\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-DEPTH\"}), \"node_name\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-NODE_NAME\"}), \"parent_node\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-PARENT_NODE\"}), \"stmnt_from_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_FROM_IDX\"}), \"stmnt_to_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_TO_IDX\"})}, \"lcl_section_source_comments=>ty_node\");\r\n    let l_node_new = new abap.types.Structure({\"depth\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-DEPTH\"}), \"node_name\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-NODE_NAME\"}), \"parent_node\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-PARENT_NODE\"}), \"stmnt_from_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_FROM_IDX\"}), \"stmnt_to_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_TO_IDX\"})}, \"lcl_section_source_comments=>ty_node\");\r\n    let l_name_node = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let l_name_concatenated = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let l_parent = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let l_line_code = new abap.types.String();\r\n    let line_comment_block = new abap.types.Structure({\"tab_comments\": new abap.types.Table(new abap.types.String(), {\"withHeader\":false}, \"STRING_TABLE\"), \"column_first_comment\": new abap.types.Integer({qualifiedName: \"TY_COMMENT_BLOCK-COLUMN_FIRST_COMMENT\"}), \"hook_relevant_tok_type\": new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), \"hook_relevant_tok_name\": new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), \"hook_relevant_tok_name_add\": new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), \"hook_relevant_tok_type_stmnt\": new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), \"hook_relevant_tok_name_stmnt\": new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\")}, \"ty_comment_block\");\r\n    let tab_comments_to_save = new abap.types.Table(new abap.types.String(), {\"withHeader\":false}, \"STRING_TABLE\");\r\n    let current_statement = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let relevant_token1 = new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\");\r\n    let relevant_token2 = new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\");\r\n    let relevant_token3 = new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\");\r\n    let l_depth = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let l_length = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let l_count = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let l_from = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let l_to = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let embeded_types = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\r\n    embeded_types.set(abap.builtin.abap_false);\r\n    let embeded_data_const = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\r\n    embeded_data_const.set(abap.builtin.abap_false);\r\n    let nodes = new abap.types.Table(new abap.types.String(), {\"withHeader\":false}, \"STRING_TABLE\");\r\n    let hierarchy_nodes_descending = new abap.types.Table(new abap.types.Structure({\"depth\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-DEPTH\"}), \"node_name\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-NODE_NAME\"}), \"parent_node\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-PARENT_NODE\"}), \"stmnt_from_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_FROM_IDX\"}), \"stmnt_to_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_TO_IDX\"})}, \"lcl_section_source_comments=>ty_node\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_nodes\");\r\n    let fs_fs_stmnt_ = new abap.types.FieldSymbol(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"));\r\n    let fs_fs_stmnt_prev_ = new abap.types.FieldSymbol(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"));\r\n    let fs_fs_stmnt_next_ = new abap.types.FieldSymbol(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"));\r\n    let fs_fs_tok_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_tok_prev_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_tok_prev_plus_1_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let l_line_code_condensed = new abap.types.String();\r\n    let l_hier = new abap.types.Structure({\"depth\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-DEPTH\"}), \"node_name\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-NODE_NAME\"}), \"parent_node\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-PARENT_NODE\"}), \"stmnt_from_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_FROM_IDX\"}), \"stmnt_to_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_TO_IDX\"})}, \"lcl_section_source_comments=>ty_node\");\r\n    abap.statements.clear(tab_abap_doc);\r\n    await this.me.get().build_hierarchy_nodes({tab_statements: tab_statements, tab_tokens: tab_tokens, nodes: this.me.get().hierarchy_nodes});\r\n    for await (const unique21 of abap.statements.loop(tab_statements,{where: async (I) => {return abap.compare.eq(I.type, new abap.types.Character(1).set('P')) || abap.compare.eq(I.type, new abap.types.Character(1).set('S'));}})) {\r\n      fs_fs_stmnt_.assign(unique21);\r\n      abap.statements.clear(tab_comments_to_save);\r\n      abap.statements.clear(relevant_token1);\r\n      abap.statements.clear(relevant_token2);\r\n      abap.statements.clear(relevant_token3);\r\n      abap.statements.clear(line_comment_block);\r\n      abap.statements.clear(l_name_concatenated);\r\n      current_statement.set(abap.builtin.sy.get().tabix);\r\n      for await (const unique22 of abap.statements.loop(tab_tokens,{from: fs_fs_stmnt_.get().from,to: fs_fs_stmnt_.get().to})) {\r\n        fs_fs_tok_.assign(unique22);\r\n        abap.statements.readTable(tab_source,{index: fs_fs_tok_.get().row,into: l_line_code});\r\n        if (abap.compare.gt(fs_fs_tok_.get().col, new abap.types.Integer().set(0))) {\r\n          l_length.set(abap.operators.minus(fs_fs_tok_.get().col,new abap.types.Integer().set(1)));\r\n          if (abap.compare.gt(l_length, new abap.types.Integer().set(0))) {\r\n            if (!((abap.compare.co(l_line_code.getOffset({length: l_length}), abap.builtin.space)))) {\r\n              continue;\r\n            }\r\n          }\r\n        }\r\n        l_line_code_condensed.set(l_line_code);\r\n        abap.statements.condense(l_line_code_condensed, {nogaps: false});\r\n        if (abap.compare.eq(l_line_code_condensed.getOffset({length: 2}), new abap.types.Character(2).set('\"!'))) {\r\n          abap.statements.append({source: l_line_code, target: tab_comments_to_save});\r\n        }\r\n      }\r\n      if (!(abap.compare.initial(tab_comments_to_save) === false)) {\r\n        continue;\r\n      }\r\n      embeded_types.set(abap.builtin.abap_false);\r\n      embeded_data_const.set(abap.builtin.abap_false);\r\n      for await (const unique23 of abap.statements.loop(tab_statements,{to: current_statement,where: async (I) => {return (abap.compare.ne(I.type, new abap.types.Character(1).set('P')) && abap.compare.ne(I.type, new abap.types.Character(1).set('S')) && abap.compare.ne(I.type, new abap.types.Character(1).set('G')));}})) {\r\n        fs_fs_stmnt_prev_.assign(unique23);\r\n      }\r\n      if (abap.compare.assigned(fs_fs_stmnt_prev_)) {\r\n        abap.statements.readTable(tab_tokens,{index: fs_fs_stmnt_prev_.get().from,assigning: fs_fs_tok_prev_});\r\n        if (abap.compare.eq(fs_fs_tok_prev_.get().str, new abap.types.Character(7).set('INCLUDE'))) {\r\n          abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_prev_.get().from,new abap.types.Integer().set(1)),assigning: fs_fs_tok_prev_plus_1_});\r\n        }\r\n        if ((abap.compare.eq(fs_fs_tok_prev_.get().str, new abap.types.Character(8).set('ENDCLASS')))) {\r\n          break;\r\n        }\r\n        if (abap.compare.eq(fs_fs_tok_prev_.get().str, new abap.types.Character(5).set('TYPES')) || (abap.compare.eq(fs_fs_tok_prev_.get().str, new abap.types.Character(7).set('INCLUDE')) && abap.compare.assigned(fs_fs_tok_prev_plus_1_) && abap.compare.eq(fs_fs_tok_prev_plus_1_.get().str, new abap.types.Character(4).set('TYPE')))) {\r\n          if (abap.compare.eq((await this.me.get().is_within_types_begin_end_of({tab_statements: tab_statements, tab_tokens: tab_tokens, limit: fs_fs_stmnt_.get().from})), abap.builtin.abap_true)) {\r\n            embeded_types.set(abap.builtin.abap_true);\r\n          }\r\n        }\r\n        if ((abap.compare.eq(fs_fs_tok_prev_.get().str, new abap.types.Character(4).set('DATA')) || abap.compare.eq(fs_fs_tok_prev_.get().str, new abap.types.Character(10).set('CLASS-DATA')) || abap.compare.eq(fs_fs_tok_prev_.get().str, new abap.types.Character(9).set('CONSTANTS')))) {\r\n          if (abap.compare.eq((await this.me.get().is_within_data_begin_end_of({tab_statements: tab_statements, tab_tokens: tab_tokens, limit: fs_fs_stmnt_.get().from})), abap.builtin.abap_true)) {\r\n            embeded_data_const.set(abap.builtin.abap_true);\r\n          }\r\n        }\r\n      }\r\n      for await (const unique24 of abap.statements.loop(tab_statements,{from: abap.operators.add(current_statement,new abap.types.Integer().set(1)),where: async (I) => {return (abap.compare.ne(I.type, new abap.types.Character(1).set('P')) && abap.compare.ne(I.type, new abap.types.Character(1).set('S')) && abap.compare.ne(I.type, new abap.types.Character(1).set('G')));}})) {\r\n        fs_fs_stmnt_next_.assign(unique24);\r\n        break;\r\n      }\r\n      if (abap.compare.assigned(fs_fs_stmnt_next_)) {\r\n        for await (const unique25 of abap.statements.loop(tab_tokens,{from: fs_fs_stmnt_next_.get().from,where: async (I) => {return abap.compare.ne(I.type, new abap.types.Character(1).set('C'));}})) {\r\n          fs_fs_tok_.assign(unique25);\r\n          if (abap.compare.initial(relevant_token2) && abap.compare.initial(relevant_token1) === false) {\r\n            relevant_token2.set(fs_fs_tok_);\r\n            if (abap.compare.eq(relevant_token1.get().str, new abap.types.Character(5).set('CLASS'))) {\r\n              abap.statements.readTable(tab_tokens,{index: abap.operators.add(abap.builtin.sy.get().tabix,new abap.types.Integer().set(1)),into: relevant_token3});\r\n              if (abap.compare.eq(relevant_token3.get().str, new abap.types.Character(10).set('DEFINITION')) && abap.compare.ne(relevant_token2.get().str, this.clsname)) {\r\n                relevant_token2.get().str.set(this.clsname);\r\n              }\r\n              abap.statements.clear(relevant_token3);\r\n            }\r\n            if ((abap.compare.eq(relevant_token1.get().str, new abap.types.Character(5).set('TYPES')) && abap.compare.eq(relevant_token2.get().str, new abap.types.Character(5).set('BEGIN'))) || (abap.compare.eq(relevant_token1.get().str, new abap.types.Character(4).set('DATA')) && abap.compare.eq(relevant_token2.get().str, new abap.types.Character(5).set('BEGIN'))) || (abap.compare.eq(relevant_token1.get().str, new abap.types.Character(10).set('CLASS-DATA')) && abap.compare.eq(relevant_token2.get().str, new abap.types.Character(5).set('BEGIN'))) || (abap.compare.eq(relevant_token1.get().str, new abap.types.Character(9).set('CONSTANTS')) && abap.compare.eq(relevant_token2.get().str, new abap.types.Character(5).set('BEGIN')))) {\r\n              abap.statements.readTable(tab_tokens,{index: abap.operators.add(abap.builtin.sy.get().tabix,new abap.types.Integer().set(2)),into: relevant_token3});\r\n              if ((abap.compare.eq(relevant_token1.get().str, new abap.types.Character(5).set('TYPES')) && abap.compare.eq(relevant_token3.get().str, new abap.types.Character(4).set('MESH')) && abap.compare.eq(abap.operators.minus(fs_fs_stmnt_next_.get().to,fs_fs_stmnt_next_.get().from), new abap.types.Integer().set(4)))) {\r\n                abap.statements.readTable(tab_tokens,{index: abap.operators.add(abap.builtin.sy.get().tabix,new abap.types.Integer().set(1)),into: relevant_token3});\r\n              } else if ((abap.compare.eq(relevant_token1.get().str, new abap.types.Character(5).set('TYPES')) && abap.compare.eq(relevant_token3.get().str, new abap.types.Character(4).set('ENUM')) && abap.compare.gt(abap.operators.minus(fs_fs_stmnt_next_.get().to,fs_fs_stmnt_next_.get().from), new abap.types.Integer().set(5)))) {\r\n                abap.statements.readTable(tab_tokens,{index: abap.operators.add(abap.builtin.sy.get().tabix,new abap.types.Integer().set(1)),into: relevant_token3});\r\n              }\r\n            }\r\n            break;\r\n          }\r\n          if (abap.compare.initial(relevant_token1)) {\r\n            relevant_token1.set(fs_fs_tok_);\r\n          }\r\n        }\r\n        if (abap.compare.initial(relevant_token3.get().str) === false) {\r\n          l_name_node.set(relevant_token3.get().str);\r\n        } else {\r\n          l_name_node.set(relevant_token2.get().str);\r\n        }\r\n        if (abap.compare.eq(relevant_token1.get().str, new abap.types.Character(5).set('TYPES')) || abap.compare.eq(relevant_token1.get().str, new abap.types.Character(4).set('DATA')) || abap.compare.eq(relevant_token1.get().str, new abap.types.Character(10).set('CLASS-DATA')) || abap.compare.eq(relevant_token1.get().str, new abap.types.Character(9).set('CONSTANTS'))) {\r\n          abap.statements.append({source: l_name_node, target: nodes});\r\n          abap.statements.clear(l_count);\r\n          abap.statements.clear(l_from);\r\n          abap.statements.clear(l_to);\r\n          for await (const unique26 of abap.statements.loop(this.me.get().hierarchy_nodes)) {\r\n            l_hier.set(unique26);\r\n            if (!(abap.compare.eq(l_hier.get().depth, new abap.types.Integer().set(0)) && abap.compare.gt(l_hier.get().stmnt_from_idx, new abap.types.Integer().set(0)) && abap.compare.le(l_hier.get().stmnt_from_idx, fs_fs_stmnt_next_.get().from))) {\r\n              continue;\r\n            }\r\n            l_from.set(abap.builtin.sy.get().tabix);\r\n          }\r\n          if (abap.compare.gt(l_from, new abap.types.Integer().set(0))) {\r\n            for await (const unique27 of abap.statements.loop(this.me.get().hierarchy_nodes,{from: abap.operators.add(l_from,new abap.types.Integer().set(1)),where: async (I) => {return abap.compare.eq(I.depth, new abap.types.Integer().set(0));}})) {\r\n              l_hier.set(unique27);\r\n              l_to.set(abap.builtin.sy.get().tabix);\r\n              break;\r\n            }\r\n            if (abap.compare.ne(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0)) || abap.compare.eq(l_to, new abap.types.Integer().set(0))) {\r\n              l_to.set(abap.builtin.lines({val: this.me.get().hierarchy_nodes}));\r\n            } else if (abap.compare.gt(l_to, l_from)) {\r\n              l_to.set(abap.operators.minus(l_to,new abap.types.Integer().set(1)));\r\n            }\r\n            for await (const unique28 of abap.statements.loop(this.me.get().hierarchy_nodes,{from: l_from,to: l_to,where: async (I) => {return abap.compare.eq(I.node_name, l_name_node) && abap.compare.eq(I.depth, this.me.get().depth);}})) {\r\n              l_node.set(unique28);\r\n              l_depth.set(l_node.get().depth);\r\n              l_parent.set(l_node.get().parent_node);\r\n              const indexBackup1 = abap.builtin.sy.get().index.get();\r\n              let unique29 = 1;\r\n              while (abap.compare.ne(l_depth, new abap.types.Integer().set(0))) {\r\n                abap.builtin.sy.get().index.set(unique29++);\r\n                abap.statements.clear(hierarchy_nodes_descending);\r\n                for await (const unique30 of abap.statements.loop(this.me.get().hierarchy_nodes,{from: l_from,to: l_to,where: async (I) => {return abap.compare.eq(I.node_name, l_parent) && abap.compare.lt(I.depth, l_depth);}})) {\r\n                  l_node_new.set(unique30);\r\n                  abap.statements.append({source: l_node_new, target: hierarchy_nodes_descending});\r\n                }\r\n                abap.statements.sort(hierarchy_nodes_descending,{by: [{component: \"depth\", descending: true}]});\r\n                for await (const unique31 of abap.statements.loop(hierarchy_nodes_descending,{where: async (I) => {return abap.compare.eq(I.node_name, l_parent) && abap.compare.lt(I.depth, l_depth);}})) {\r\n                  l_node_new.set(unique31);\r\n                  abap.statements.insertInternal({data: l_node_new.get().node_name, index: new abap.types.Integer().set(1), table: nodes});\r\n                }\r\n                if (abap.compare.ne(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0))) {\r\n                  break;\r\n                }\r\n                l_depth.set(l_node_new.get().depth);\r\n                l_parent.set(l_node_new.get().parent_node);\r\n              }\r\n              abap.builtin.sy.get().index.set(indexBackup1);\r\n            }\r\n          }\r\n        }\r\n        if (abap.compare.le(abap.builtin.lines({val: nodes}), new abap.types.Integer().set(1))) {\r\n          abap.statements.clear(l_name_concatenated);\r\n        } else {\r\n          for await (const unique32 of abap.statements.loop(nodes)) {\r\n            l_name_node.set(unique32);\r\n            if (abap.compare.initial(l_name_concatenated)) {\r\n              l_name_concatenated.set(l_name_node);\r\n            } else {\r\n              l_name_concatenated.set(abap.operators.concat(l_name_concatenated,abap.operators.concat(new abap.types.Character(1).set('-'),l_name_node)));\r\n            }\r\n          }\r\n        }\r\n      }\r\n      line_comment_block.get().tab_comments.set(tab_comments_to_save);\r\n      line_comment_block.get().hook_relevant_tok_type.set(relevant_token1);\r\n      line_comment_block.get().hook_relevant_tok_name.set(relevant_token2);\r\n      line_comment_block.get().hook_relevant_tok_name_add.set(relevant_token3);\r\n      if (abap.compare.cs(l_name_concatenated, new abap.types.Character(1).set('-')) && (abap.compare.eq(embeded_types, abap.builtin.abap_true) || abap.compare.eq(embeded_data_const, abap.builtin.abap_true))) {\r\n        if (abap.compare.initial(line_comment_block.get().hook_relevant_tok_name_add) === false) {\r\n          line_comment_block.get().hook_relevant_tok_name_add.get().str.set(l_name_concatenated);\r\n        } else if (abap.compare.initial(line_comment_block.get().hook_relevant_tok_name) === false) {\r\n          line_comment_block.get().hook_relevant_tok_name.get().str.set(l_name_concatenated);\r\n        }\r\n      }\r\n      abap.statements.append({source: line_comment_block, target: tab_abap_doc});\r\n      abap.statements.clear(nodes);\r\n      abap.statements.clear(l_name_concatenated);\r\n    }\r\n    return tab_abap_doc;\r\n  }\r\n  async build_hierarchy_nodes(INPUT) {\r\n    let tab_statements = new abap.types.Table(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_sstmnt\");\r\n    if (INPUT && INPUT.tab_statements) {tab_statements.set(INPUT.tab_statements);}\r\n    let tab_tokens = new abap.types.Table(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_stokesx\");\r\n    if (INPUT && INPUT.tab_tokens) {tab_tokens.set(INPUT.tab_tokens);}\r\n    let nodes = new abap.types.Table(new abap.types.Structure({\"depth\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-DEPTH\"}), \"node_name\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-NODE_NAME\"}), \"parent_node\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-PARENT_NODE\"}), \"stmnt_from_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_FROM_IDX\"}), \"stmnt_to_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_TO_IDX\"})}, \"lcl_section_source_comments=>ty_node\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_nodes\");\r\n    if (INPUT && INPUT.nodes) {nodes = INPUT.nodes;}\r\n    let l_count_begin = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let l_count_end = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let l_node_root = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let l_node = new abap.types.Structure({\"depth\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-DEPTH\"}), \"node_name\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-NODE_NAME\"}), \"parent_node\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-PARENT_NODE\"}), \"stmnt_from_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_FROM_IDX\"}), \"stmnt_to_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_TO_IDX\"})}, \"lcl_section_source_comments=>ty_node\");\r\n    let l_depth = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let parents = new abap.types.Table(new abap.types.String(), {\"withHeader\":false}, \"STRING_TABLE\");\r\n    let fs_fs_stmnt_ = new abap.types.FieldSymbol(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"));\r\n    let fs_fs_tok_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_tok_next2_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_tok_next1_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_tok_next3_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let fs_fs_tok_next4_ = new abap.types.FieldSymbol(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"));\r\n    let temp3 = new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\");\r\n    let temp4 = new abap.types.Integer();\r\n    let temp1 = new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\");\r\n    let temp2 = new abap.types.Integer();\r\n    let temp8 = new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\");\r\n    let temp9 = new abap.types.Integer();\r\n    let temp10 = new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\");\r\n    let temp11 = new abap.types.Integer();\r\n    let l_lines = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let temp5 = new abap.types.String();\r\n    let temp6 = new abap.types.Integer();\r\n    let temp7 = new abap.types.Integer();\r\n    abap.statements.clear(nodes);\r\n    for await (const unique33 of abap.statements.loop(tab_statements,{where: async (I) => {return (abap.compare.ne(I.type, new abap.types.Character(1).set('P')) && abap.compare.ne(I.type, new abap.types.Character(1).set('S')) && abap.compare.ne(I.type, new abap.types.Character(1).set('G')));}})) {\r\n      fs_fs_stmnt_.assign(unique33);\r\n      temp4.set(abap.builtin.sy.get().tabix);\r\n      abap.statements.readTable(tab_tokens,{index: fs_fs_stmnt_.get().from,into: temp3});\r\n      abap.builtin.sy.get().tabix.set(temp4);\r\n      if (abap.compare.ne(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0))) {\r\n        throw await (new abap.Classes['CX_SY_ITAB_LINE_NOT_FOUND']()).constructor_();\r\n      }\r\n      temp2.set(abap.builtin.sy.get().tabix);\r\n      abap.statements.readTable(tab_tokens,{index: fs_fs_stmnt_.get().from,into: temp1});\r\n      abap.builtin.sy.get().tabix.set(temp2);\r\n      if (abap.compare.ne(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0))) {\r\n        throw await (new abap.Classes['CX_SY_ITAB_LINE_NOT_FOUND']()).constructor_();\r\n      }\r\n      temp9.set(abap.builtin.sy.get().tabix);\r\n      abap.statements.readTable(tab_tokens,{index: fs_fs_stmnt_.get().from,into: temp8});\r\n      abap.builtin.sy.get().tabix.set(temp9);\r\n      if (abap.compare.ne(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0))) {\r\n        throw await (new abap.Classes['CX_SY_ITAB_LINE_NOT_FOUND']()).constructor_();\r\n      }\r\n      temp11.set(abap.builtin.sy.get().tabix);\r\n      abap.statements.readTable(tab_tokens,{index: fs_fs_stmnt_.get().from,into: temp10});\r\n      abap.builtin.sy.get().tabix.set(temp11);\r\n      if (abap.compare.ne(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0))) {\r\n        throw await (new abap.Classes['CX_SY_ITAB_LINE_NOT_FOUND']()).constructor_();\r\n      }\r\n      if (!(abap.compare.eq(temp3.get().str, new abap.types.Character(5).set('TYPES')) || abap.compare.eq(temp1.get().str, new abap.types.Character(4).set('DATA')) || abap.compare.eq(temp8.get().str, new abap.types.Character(10).set('CLASS-DATA')) || abap.compare.eq(temp10.get().str, new abap.types.Character(9).set('CONSTANTS')))) {\r\n        continue;\r\n      }\r\n      for await (const unique34 of abap.statements.loop(tab_tokens,{from: fs_fs_stmnt_.get().from,to: fs_fs_stmnt_.get().to})) {\r\n        fs_fs_tok_.assign(unique34);\r\n        if (!((abap.compare.eq(fs_fs_tok_.get().str, new abap.types.Character(5).set('TYPES')) || abap.compare.eq(fs_fs_tok_.get().str, new abap.types.Character(4).set('DATA')) || abap.compare.eq(fs_fs_tok_.get().str, new abap.types.Character(10).set('CLASS-DATA')) || abap.compare.eq(fs_fs_tok_.get().str, new abap.types.Character(9).set('CONSTANTS'))))) {\r\n          continue;\r\n        }\r\n        abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_.get().from,new abap.types.Integer().set(1)),assigning: fs_fs_tok_next1_});\r\n        abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_.get().from,new abap.types.Integer().set(2)),assigning: fs_fs_tok_next2_});\r\n        abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_.get().from,new abap.types.Integer().set(3)),assigning: fs_fs_tok_next3_});\r\n        if (abap.compare.assigned(fs_fs_tok_next1_) && abap.compare.assigned(fs_fs_tok_next2_) && abap.compare.assigned(fs_fs_tok_next3_)) {\r\n          if ((abap.compare.eq(fs_fs_tok_next1_.get().str, new abap.types.Character(5).set('BEGIN')) && abap.compare.eq(fs_fs_tok_next2_.get().str, new abap.types.Character(2).set('OF')))) {\r\n            l_node.get().node_name.set(fs_fs_tok_next3_.get().str);\r\n            l_node.get().stmnt_from_idx.set(fs_fs_stmnt_.get().from);\r\n            l_node.get().stmnt_to_idx.set(fs_fs_stmnt_.get().to);\r\n            if (abap.compare.eq(fs_fs_tok_.get().str, new abap.types.Character(5).set('TYPES')) && (abap.compare.eq(l_node.get().node_name, new abap.types.Character(4).set('MESH')) || abap.compare.eq(l_node.get().node_name, new abap.types.Character(4).set('ENUM')))) {\r\n              abap.statements.readTable(tab_tokens,{index: abap.operators.add(fs_fs_stmnt_.get().from,new abap.types.Integer().set(4)),assigning: fs_fs_tok_next4_});\r\n              l_node.get().node_name.set(fs_fs_tok_next4_.get().str);\r\n            }\r\n            if (abap.compare.eq(l_depth, new abap.types.Integer().set(0))) {\r\n              l_node_root.set(fs_fs_tok_next3_.get().str);\r\n              l_node.get().depth.set(new abap.types.Integer().set(0));\r\n              abap.statements.append({source: l_node, target: nodes});\r\n              l_node.get().parent_node.set(l_node_root);\r\n            } else {\r\n              l_node.get().depth.set(l_depth);\r\n              abap.statements.append({source: l_node, target: nodes});\r\n            }\r\n            abap.statements.append({source: l_node.get().node_name, target: parents});\r\n            l_node.get().parent_node.set(l_node.get().node_name);\r\n            l_depth.set(abap.operators.add(l_depth,new abap.types.Integer().set(1)));\r\n            l_count_begin.set(abap.operators.add(l_count_begin,new abap.types.Integer().set(1)));\r\n          } else if ((abap.compare.eq(fs_fs_tok_next1_.get().str, new abap.types.Character(3).set('END')) && abap.compare.eq(fs_fs_tok_next2_.get().str, new abap.types.Character(2).set('OF')))) {\r\n            l_depth.set(abap.operators.minus(l_depth,new abap.types.Integer().set(1)));\r\n            l_count_end.set(abap.operators.add(l_count_end,new abap.types.Integer().set(1)));\r\n            if (abap.compare.eq(l_depth, new abap.types.Integer().set(0))) {\r\n              abap.statements.clear(l_count_begin);\r\n              abap.statements.clear(l_count_end);\r\n              abap.statements.clear(l_node);\r\n              abap.statements.clear(l_node_root);\r\n              abap.statements.clear(parents);\r\n              continue;\r\n            }\r\n            l_lines.set(abap.builtin.lines({val: parents}));\r\n            await abap.statements.deleteInternal(parents,{index: l_lines});\r\n            temp6.set(abap.builtin.sy.get().tabix);\r\n            abap.statements.readTable(parents,{index: l_depth,into: temp5});\r\n            abap.builtin.sy.get().tabix.set(temp6);\r\n            if (abap.compare.ne(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0))) {\r\n              throw await (new abap.Classes['CX_SY_ITAB_LINE_NOT_FOUND']()).constructor_();\r\n            }\r\n            l_node.get().parent_node.set(temp5);\r\n          } else {\r\n            l_node.get().stmnt_from_idx.set(fs_fs_stmnt_.get().from);\r\n            l_node.get().stmnt_to_idx.set(fs_fs_stmnt_.get().to);\r\n            l_node.get().node_name.set(fs_fs_tok_next1_.get().str);\r\n            l_node.get().depth.set(l_depth);\r\n            abap.statements.readTable(nodes,{withKey: (i) => {return abap.compare.eq(i.table_line, l_node);}});\r\n            temp7.set(abap.builtin.sy.get().subrc);\r\n            if (!abap.compare.eq(temp7, new abap.types.Integer().set(0))) {\r\n              abap.statements.append({source: l_node, target: nodes});\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\nabap.Classes['CLAS-ZCL_AFF_ABAP_DOC_READER-LCL_SECTION_SOURCE_COMMENTS'] = lcl_section_source_comments;\r\nlcl_section_source_comments.ty_stokesx = new abap.types.Table(new abap.types.Structure({\"str\": new abap.types.String(), \"row\": new abap.types.Integer(), \"off2\": new abap.types.Integer(), \"off3\": new abap.types.Integer(), \"col\": new abap.types.Integer(), \"len1\": new abap.types.Integer(), \"len2\": new abap.types.Integer(), \"len3\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {})}, \"STOKESX\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_stokesx\");\r\nlcl_section_source_comments.ty_sstmnt = new abap.types.Table(new abap.types.Structure({\"level\": new abap.types.Integer(), \"struc\": new abap.types.Integer(), \"from\": new abap.types.Integer(), \"to\": new abap.types.Integer(), \"number\": new abap.types.Integer(), \"colonrow\": new abap.types.Integer(), \"trow\": new abap.types.Integer(), \"coloncol\": new abap.types.Integer(), \"tcol\": new abap.types.Integer(), \"prefixlen\": new abap.types.Integer(), \"type\": new abap.types.Character(1, {}), \"terminator\": new abap.types.Character(1, {}), \"enhmt\": new abap.types.Integer()}, \"SSTMNT\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_sstmnt\");\r\nlcl_section_source_comments.ty_node = new abap.types.Structure({\"depth\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-DEPTH\"}), \"node_name\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-NODE_NAME\"}), \"parent_node\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-PARENT_NODE\"}), \"stmnt_from_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_FROM_IDX\"}), \"stmnt_to_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_TO_IDX\"})}, \"lcl_section_source_comments=>ty_node\");\r\nlcl_section_source_comments.ty_nodes = new abap.types.Table(new abap.types.Structure({\"depth\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-DEPTH\"}), \"node_name\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-NODE_NAME\"}), \"parent_node\": new abap.types.String({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-PARENT_NODE\"}), \"stmnt_from_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_FROM_IDX\"}), \"stmnt_to_idx\": new abap.types.Integer({qualifiedName: \"LCL_SECTION_SOURCE_COMMENTS=>TY_NODE-STMNT_TO_IDX\"})}, \"lcl_section_source_comments=>ty_node\"), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_section_source_comments=>ty_nodes\");\r\n\r\n//# sourceMappingURL=zcl_aff_abap_doc_reader.clas.locals.mjs.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://aff-web/./output_abap/zcl_aff_abap_doc_reader.clas.locals.mjs?");

/***/ })

}]);