"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkaff_web"] = self["webpackChunkaff_web"] || []).push([["output_abap_cl_ixml_clas_locals_mjs"],{

/***/ "./output_abap/cl_ixml.clas.locals.mjs":
/*!*********************************************!*\
  !*** ./output_abap/cl_ixml.clas.locals.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lcl_document\": () => (/* binding */ lcl_document),\n/* harmony export */   \"lcl_encoding\": () => (/* binding */ lcl_encoding),\n/* harmony export */   \"lcl_escape\": () => (/* binding */ lcl_escape),\n/* harmony export */   \"lcl_istream\": () => (/* binding */ lcl_istream),\n/* harmony export */   \"lcl_named_node_map\": () => (/* binding */ lcl_named_node_map),\n/* harmony export */   \"lcl_node\": () => (/* binding */ lcl_node),\n/* harmony export */   \"lcl_node_iterator\": () => (/* binding */ lcl_node_iterator),\n/* harmony export */   \"lcl_node_list\": () => (/* binding */ lcl_node_list),\n/* harmony export */   \"lcl_ostream\": () => (/* binding */ lcl_ostream),\n/* harmony export */   \"lcl_parser\": () => (/* binding */ lcl_parser),\n/* harmony export */   \"lcl_renderer\": () => (/* binding */ lcl_renderer),\n/* harmony export */   \"lcl_stream_factory\": () => (/* binding */ lcl_stream_factory)\n/* harmony export */ });\nconst {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ \"./output_abap/cx_root.clas.mjs\"));\r\n// cl_ixml.clas.locals_imp.abap\r\nclass lcl_escape {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    return this;\r\n  }\r\n  async unescape_value(INPUT) {\r\n    return lcl_escape.unescape_value(INPUT);\r\n  }\r\n  static async unescape_value(INPUT) {\r\n    let rv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let iv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_value) {iv_value.set(INPUT.iv_value);}\r\n    rv_value.set(iv_value);\r\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(1).set('&'), of: new abap.types.Character(5).set('&amp;')});\r\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(1).set('<'), of: new abap.types.Character(4).set('&lt;')});\r\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(1).set('>'), of: new abap.types.Character(4).set('&gt;')});\r\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(1).set('\"'), of: new abap.types.Character(6).set('&quot;')});\r\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.String().set(`'`), of: new abap.types.Character(6).set('&apos;')});\r\n    return rv_value;\r\n  }\r\n  async escape_value(INPUT) {\r\n    return lcl_escape.escape_value(INPUT);\r\n  }\r\n  static async escape_value(INPUT) {\r\n    let rv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let iv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_value) {iv_value.set(INPUT.iv_value);}\r\n    rv_value.set(iv_value);\r\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(5).set('&amp;'), of: new abap.types.Character(1).set('&')});\r\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(4).set('&lt;'), of: new abap.types.Character(1).set('<')});\r\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(4).set('&gt;'), of: new abap.types.Character(1).set('>')});\r\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(6).set('&quot;'), of: new abap.types.Character(1).set('\"')});\r\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(6).set('&apos;'), of: new abap.types.String().set(`'`)});\r\n    return rv_value;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_ESCAPE'] = lcl_escape;\r\nclass lcl_node_iterator {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_NODE_ITERATOR\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mv_pointer = new abap.types.Integer({qualifiedName: \"I\"});\r\n    this.mt_list = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_node_iterator=>ty_list\");\r\n    let it_list = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_node_iterator=>ty_list\");\r\n    if (INPUT && INPUT.it_list) {it_list.set(INPUT.it_list);}\r\n    this.mt_list.set(it_list);\r\n    this.mv_pointer.set(new abap.types.Integer().set(1));\r\n    return this;\r\n  }\r\n  async if_ixml_node_iterator$reset() {\r\n    this.mv_pointer.set(new abap.types.Integer().set(1));\r\n  }\r\n  async if_ixml_node_iterator$get_next() {\r\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    abap.statements.readTable(this.mt_list,{index: this.mv_pointer,into: rval});\r\n    this.mv_pointer.set(abap.operators.add(this.mv_pointer,new abap.types.Integer().set(1)));\r\n    return rval;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_NODE_ITERATOR'] = lcl_node_iterator;\r\nlcl_node_iterator.ty_list = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_node_iterator=>ty_list\");\r\nclass lcl_encoding {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_ENCODING\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    return this;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_ENCODING'] = lcl_encoding;\r\nclass lcl_named_node_map {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_NAMED_NODE_MAP\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mt_list = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"\");\r\n    return this;\r\n  }\r\n  async if_ixml_named_node_map$create_iterator() {\r\n    let iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\r\n    iterator.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE_ITERATOR']()).constructor_({it_list: this.mt_list}));\r\n    return iterator;\r\n  }\r\n  async if_ixml_named_node_map$get_length() {\r\n    let val = new abap.types.Integer({qualifiedName: \"I\"});\r\n    val.set(abap.builtin.lines({val: this.mt_list}));\r\n    return val;\r\n  }\r\n  async if_ixml_named_node_map$get_named_item_ns(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    for await (const unique97 of abap.statements.loop(this.mt_list)) {\r\n      li_node.set(unique97);\r\n      if (abap.compare.eq((await li_node.get().if_ixml_node$get_name()), name)) {\r\n        val.set(li_node);\r\n        return val;\r\n      }\r\n    }\r\n    return val;\r\n  }\r\n  async if_ixml_named_node_map$get_named_item(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_named_node_map$remove_named_item(INPUT) {\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n  }\r\n  async if_ixml_named_node_map$set_named_item_ns(INPUT) {\r\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.node) {node.set(INPUT.node);}\r\n    abap.statements.append({source: node, target: this.mt_list});\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_NAMED_NODE_MAP'] = lcl_named_node_map;\r\nclass lcl_node_list {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_NODE_LIST\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mt_list = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"\");\r\n    return this;\r\n  }\r\n  async append(INPUT) {\r\n    let ii_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.ii_node) {ii_node.set(INPUT.ii_node);}\r\n    abap.statements.assert(abap.compare.initial(ii_node) === false);\r\n    abap.statements.append({source: ii_node, target: this.mt_list});\r\n  }\r\n  async remove(INPUT) {\r\n    let ii_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.ii_node) {ii_node.set(INPUT.ii_node);}\r\n    abap.statements.readTable(this.mt_list,{withKey: (i) => {return abap.compare.eq(i.table_line, ii_node);}});\r\n    if (abap.compare.eq(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0))) {\r\n      await abap.statements.deleteInternal(this.mt_list,{index: abap.builtin.sy.get().tabix});\r\n    }\r\n  }\r\n  async if_ixml_node_list$get_length() {\r\n    let length = new abap.types.Integer({qualifiedName: \"I\"});\r\n    length.set(abap.builtin.lines({val: this.mt_list}));\r\n    return length;\r\n  }\r\n  async if_ixml_node_list$create_iterator() {\r\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\r\n    rval.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE_ITERATOR']()).constructor_({it_list: this.mt_list}));\r\n    return rval;\r\n  }\r\n  async if_ixml_node_list$get_item(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    let index = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (INPUT && INPUT.index) {index.set(INPUT.index);}\r\n    abap.statements.readTable(this.mt_list,{index: index,into: val});\r\n    return val;\r\n  }\r\n  async if_ixml_node_list$create_rev_iterator_filtered(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\r\n    let filter = new abap.types.Character(4);\r\n    if (INPUT && INPUT.filter) {filter = INPUT.filter;}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_NODE_LIST'] = lcl_node_list;\r\nclass lcl_node {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_ELEMENT\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mv_name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    this.mv_namespace = new abap.types.String({qualifiedName: \"STRING\"});\r\n    this.mv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    this.mo_children = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE_LIST\"});\r\n    this.mi_parent = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    this.mi_attributes = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NAMED_NODE_MAP\"});\r\n    let ii_parent = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.ii_parent) {ii_parent.set(INPUT.ii_parent);}\r\n    this.mo_children.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE_LIST']()).constructor_());\r\n    this.mi_attributes.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NAMED_NODE_MAP']()).constructor_());\r\n    this.mi_parent.set(ii_parent);\r\n    if (abap.compare.initial(this.mi_parent) === false) {\r\n      await ii_parent.get().if_ixml_node$append_child({new_child: this.me});\r\n    }\r\n    return this;\r\n  }\r\n  async if_ixml_element$get_attribute_node_ns(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ATTRIBUTE\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_node$get_namespace_prefix() {\r\n    let rv_prefix = new abap.types.String({qualifiedName: \"STRING\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return rv_prefix;\r\n  }\r\n  async if_ixml_node$get_namespace_uri() {\r\n    let rval = new abap.types.String({qualifiedName: \"STRING\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return rval;\r\n  }\r\n  async if_ixml_element$get_attributes() {\r\n    let attr = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NAMED_NODE_MAP\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return attr;\r\n  }\r\n  async if_ixml_element$get_next() {\r\n    let next = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return next;\r\n  }\r\n  async if_ixml_element$get_name() {\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return name;\r\n  }\r\n  async if_ixml_element$append_child(INPUT) {\r\n    let rc = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let new_child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\r\n    let lo_node = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\r\n    await abap.statements.cast(lo_node, new_child);\r\n    lo_node.get().mi_parent.set(this.me);\r\n    await this.mo_children.get().append({ii_node: new_child});\r\n    return rc;\r\n  }\r\n  async if_ixml_element$clone() {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_element$create_filter_node_type(INPUT) {\r\n    let val = new abap.types.DataReference(new abap.types.Character(4));\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_element$remove_attribute_ns(INPUT) {\r\n    let foo = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.foo) {foo.set(INPUT.foo);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n  }\r\n  async if_ixml_element$create_iterator() {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_element$find_from_name_ns(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\r\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\r\n    let depth = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\r\n    let li_iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\r\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    let li_children = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_LIST\"});\r\n    let lt_nodes = new abap.types.Table(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"\");\r\n    let li_top = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    abap.statements.append({source: this.me, target: lt_nodes});\r\n    for await (const unique98 of abap.statements.loop(lt_nodes)) {\r\n      li_top.set(unique98);\r\n      li_children.set((await li_top.get().if_ixml_node$get_children()));\r\n      li_iterator.set((await li_children.get().if_ixml_node_list$create_iterator()));\r\n      const indexBackup1 = abap.builtin.sy.get().index.get();\r\n      let unique99 = 1;\r\n      while (true) {\r\n        abap.builtin.sy.get().index.set(unique99++);\r\n        li_node.set((await li_iterator.get().if_ixml_node_iterator$get_next()));\r\n        if (abap.compare.initial(li_node)) {\r\n          break;\r\n        }\r\n        if (abap.compare.eq((await li_node.get().if_ixml_node$get_name()), name)) {\r\n          await abap.statements.cast(val, li_node);\r\n          abap.builtin.sy.get().index.set(indexBackup1);\r\n          return val;\r\n        }\r\n        abap.statements.append({source: li_node, target: lt_nodes});\r\n      }\r\n      abap.builtin.sy.get().index.set(indexBackup1);\r\n    }\r\n    return val;\r\n  }\r\n  async if_ixml_element$find_from_name(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\r\n    let depth = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_element$get_attribute_node(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ATTRIBUTE\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_element$get_attribute_ns(INPUT) {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\r\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    li_node.set((await (await this.if_ixml_node$get_attributes()).get().if_ixml_named_node_map$get_named_item_ns({name: name})));\r\n    if (abap.compare.initial(li_node) === false) {\r\n      val.set((await li_node.get().if_ixml_node$get_value()));\r\n    }\r\n    return val;\r\n  }\r\n  async if_ixml_element$get_attribute(INPUT) {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_element$get_children() {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_LIST\"});\r\n    val.set((await this.if_ixml_node$get_children()));\r\n    return val;\r\n  }\r\n  async if_ixml_element$get_elements_by_tag_name(INPUT) {\r\n    let val = new abap.types.Character(4);\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_element$get_elements_by_tag_name_ns(INPUT) {\r\n    let val = new abap.types.Character(4);\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_element$get_first_child() {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    val.set((await this.if_ixml_node$get_first_child()));\r\n    return val;\r\n  }\r\n  async if_ixml_element$get_value() {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    val.set((await this.if_ixml_node$get_value()));\r\n    return val;\r\n  }\r\n  async if_ixml_element$remove_attribute(INPUT) {\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n  }\r\n  async if_ixml_element$remove_node() {\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n  }\r\n  async if_ixml_element$render(INPUT) {\r\n    let ostream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_OSTREAM\"});\r\n    if (INPUT && INPUT.ostream) {ostream.set(INPUT.ostream);}\r\n    let li_iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\r\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    let li_element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let lv_attributes = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let lv_ns = new abap.types.String({qualifiedName: \"STRING\"});\r\n    li_iterator.set((await this.mi_attributes.get().if_ixml_named_node_map$create_iterator()));\r\n    const indexBackup1 = abap.builtin.sy.get().index.get();\r\n    let unique100 = 1;\r\n    while (true) {\r\n      abap.builtin.sy.get().index.set(unique100++);\r\n      li_node.set((await li_iterator.get().if_ixml_node_iterator$get_next()));\r\n      if (abap.compare.initial(li_node)) {\r\n        break;\r\n      }\r\n      lv_attributes.set(abap.operators.concat(lv_attributes,abap.operators.concat(new abap.types.String().set(` `),abap.operators.concat((await li_node.get().if_ixml_node$get_name()),abap.operators.concat(new abap.types.Character(2).set('=\"'),abap.operators.concat((await li_node.get().if_ixml_node$get_value()),new abap.types.Character(1).set('\"')))))));\r\n    }\r\n    abap.builtin.sy.get().index.set(indexBackup1);\r\n    if (abap.compare.initial(this.mv_namespace) === false) {\r\n      lv_ns.set(abap.operators.concat(this.mv_namespace,new abap.types.Character(1).set(':')));\r\n    }\r\n    await ostream.get().if_ixml_ostream$write_string({string: abap.operators.concat(new abap.types.Character(1).set('<'),abap.operators.concat(lv_ns,abap.operators.concat(this.mv_name,lv_attributes)))});\r\n    if (abap.compare.gt((await (await this.if_ixml_node$get_children()).get().if_ixml_node_list$get_length()), new abap.types.Integer().set(0)) || abap.compare.initial(this.mv_value) === false) {\r\n      await ostream.get().if_ixml_ostream$write_string({string: new abap.types.Character(1).set('>')});\r\n    }\r\n    li_iterator.set((await (await this.if_ixml_node$get_children()).get().if_ixml_node_list$create_iterator()));\r\n    const indexBackup2 = abap.builtin.sy.get().index.get();\r\n    let unique101 = 1;\r\n    while (true) {\r\n      abap.builtin.sy.get().index.set(unique101++);\r\n      await abap.statements.cast(li_element, (await li_iterator.get().if_ixml_node_iterator$get_next()));\r\n      if (abap.compare.initial(li_element)) {\r\n        break;\r\n      }\r\n      await li_element.get().if_ixml_element$render({ostream: ostream});\r\n    }\r\n    abap.builtin.sy.get().index.set(indexBackup2);\r\n    if (abap.compare.gt((await (await this.if_ixml_node$get_children()).get().if_ixml_node_list$get_length()), new abap.types.Integer().set(0)) || abap.compare.initial(this.mv_value) === false) {\r\n      await ostream.get().if_ixml_ostream$write_string({string: abap.operators.concat((await abap.Classes['CLAS-CL_IXML-LCL_ESCAPE'].escape_value({iv_value: this.mv_value})),abap.operators.concat(new abap.types.Character(2).set('</'),abap.operators.concat(lv_ns,abap.operators.concat(this.mv_name,new abap.types.Character(1).set('>')))))});\r\n    } else {\r\n      await ostream.get().if_ixml_ostream$write_string({string: new abap.types.Character(2).set('/>')});\r\n    }\r\n  }\r\n  async if_ixml_element$set_attribute_node_ns(INPUT) {\r\n    let attr = new abap.types.Character(4);\r\n    if (INPUT && INPUT.attr) {attr = INPUT.attr;}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n  }\r\n  async if_ixml_element$set_attribute(INPUT) {\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\r\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\r\n    await this.if_ixml_element$set_attribute_ns({name: name, value: value});\r\n  }\r\n  async if_ixml_element$set_attribute_ns(INPUT) {\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let prefix = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\r\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\r\n    let lo_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    lo_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\r\n    await lo_node.get().if_ixml_node$set_name({name: name});\r\n    await lo_node.get().if_ixml_node$set_value({value: value});\r\n    await this.mi_attributes.get().if_ixml_named_node_map$set_named_item_ns({node: lo_node});\r\n  }\r\n  async if_ixml_element$set_value(INPUT) {\r\n    let rc = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\r\n    await this.if_ixml_node$set_value({value: value});\r\n    return rc;\r\n  }\r\n  async if_ixml_node$set_namespace_prefix(INPUT) {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.val) {val.set(INPUT.val);}\r\n    this.mv_namespace.set(val);\r\n  }\r\n  async if_ixml_node$append_child(INPUT) {\r\n    let new_child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\r\n    let lo_node = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\r\n    await abap.statements.cast(lo_node, new_child);\r\n    lo_node.get().mi_parent.set(this.me);\r\n    await this.mo_children.get().append({ii_node: new_child});\r\n  }\r\n  async if_ixml_node$get_attributes() {\r\n    let map = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NAMED_NODE_MAP\"});\r\n    map.set(this.mi_attributes);\r\n    return map;\r\n  }\r\n  async if_ixml_node$get_first_child() {\r\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    node.set((await this.mo_children.get().if_ixml_node_list$get_item({index: new abap.types.Integer().set(1)})));\r\n    return node;\r\n  }\r\n  async if_ixml_node$get_children() {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_LIST\"});\r\n    val.set(this.mo_children);\r\n    return val;\r\n  }\r\n  async if_ixml_node$query_interface(INPUT) {\r\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_UNKNOWN\"});\r\n    let foo = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.foo) {foo.set(INPUT.foo);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return rval;\r\n  }\r\n  async if_ixml_node$remove_node() {\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n  }\r\n  async if_ixml_node$get_parent() {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    val.set(this.mi_parent);\r\n    return val;\r\n  }\r\n  async if_ixml_node$replace_child(INPUT) {\r\n    let new_child = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\r\n    let old_child = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.old_child) {old_child.set(INPUT.old_child);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n  }\r\n  async if_ixml_node$get_name() {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    val.set(this.mv_name);\r\n    return val;\r\n  }\r\n  async if_ixml_node$get_depth() {\r\n    let val = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let li_iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\r\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    let lv_max = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (abap.compare.eq((await this.mo_children.get().if_ixml_node_list$get_length()), new abap.types.Integer().set(0))) {\r\n      val.set(new abap.types.Integer().set(0));\r\n    } else {\r\n      li_iterator.set((await this.mo_children.get().if_ixml_node_list$create_iterator()));\r\n      const indexBackup1 = abap.builtin.sy.get().index.get();\r\n      let unique102 = 1;\r\n      while (true) {\r\n        abap.builtin.sy.get().index.set(unique102++);\r\n        li_node.set((await li_iterator.get().if_ixml_node_iterator$get_next()));\r\n        if (abap.compare.initial(li_node)) {\r\n          break;\r\n        }\r\n        if (abap.compare.gt((await li_node.get().if_ixml_node$get_depth()), lv_max)) {\r\n          lv_max.set((await li_node.get().if_ixml_node$get_depth()));\r\n        }\r\n      }\r\n      abap.builtin.sy.get().index.set(indexBackup1);\r\n      val.set(abap.operators.add(lv_max,new abap.types.Integer().set(1)));\r\n    }\r\n    return val;\r\n  }\r\n  async if_ixml_node$is_leaf() {\r\n    let val = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\r\n    val.set(abap.builtin.boolc(abap.compare.eq((await this.mo_children.get().if_ixml_node_list$get_length()), new abap.types.Integer().set(0))));\r\n    return val;\r\n  }\r\n  async if_ixml_node$get_namespace() {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    val.set(this.mv_namespace);\r\n    return val;\r\n  }\r\n  async if_ixml_node$get_value() {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let li_iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\r\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    let lv_max = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (abap.compare.eq((await this.mo_children.get().if_ixml_node_list$get_length()), new abap.types.Integer().set(0))) {\r\n      val.set(this.mv_value);\r\n    } else {\r\n      li_iterator.set((await this.mo_children.get().if_ixml_node_list$create_iterator()));\r\n      const indexBackup1 = abap.builtin.sy.get().index.get();\r\n      let unique103 = 1;\r\n      while (true) {\r\n        abap.builtin.sy.get().index.set(unique103++);\r\n        li_node.set((await li_iterator.get().if_ixml_node_iterator$get_next()));\r\n        if (abap.compare.initial(li_node)) {\r\n          break;\r\n        }\r\n        val.set(abap.operators.concat(val,(await li_node.get().if_ixml_node$get_value())));\r\n      }\r\n      abap.builtin.sy.get().index.set(indexBackup1);\r\n    }\r\n    return val;\r\n  }\r\n  async if_ixml_node$get_type() {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_node$set_name(INPUT) {\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    this.mv_name.set(name);\r\n  }\r\n  async if_ixml_node$remove_child(INPUT) {\r\n    let child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.child) {child.set(INPUT.child);}\r\n    await this.mo_children.get().remove({ii_node: child});\r\n  }\r\n  async if_ixml_node$set_value(INPUT) {\r\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\r\n    this.mv_value.set(value);\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_NODE'] = lcl_node;\r\nclass lcl_document {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_DOCUMENT\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mi_node = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\r\n    this.mi_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\r\n    await this.mi_node.get().if_ixml_node$set_name({name: new abap.types.Character(9).set('#document')});\r\n    return this;\r\n  }\r\n  async if_ixml_node$get_namespace_prefix() {\r\n    let rv_prefix = new abap.types.String({qualifiedName: \"STRING\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return rv_prefix;\r\n  }\r\n  async if_ixml_node$get_namespace_uri() {\r\n    let rval = new abap.types.String({qualifiedName: \"STRING\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return rval;\r\n  }\r\n  async if_ixml_node$append_child(INPUT) {\r\n    let new_child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\r\n    let lo_node = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\r\n    await abap.statements.cast(lo_node, new_child);\r\n    lo_node.get().mi_parent.set(this.me);\r\n    await this.mi_node.get().if_ixml_node$append_child({new_child: new_child});\r\n  }\r\n  async if_ixml_node$set_namespace_prefix(INPUT) {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.val) {val.set(INPUT.val);}\r\n    await this.mi_node.get().if_ixml_node$set_namespace_prefix({val: val});\r\n  }\r\n  async if_ixml_node$get_attributes() {\r\n    let map = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NAMED_NODE_MAP\"});\r\n    map.set((await this.mi_node.get().if_ixml_node$get_attributes()));\r\n    return map;\r\n  }\r\n  async if_ixml_node$get_first_child() {\r\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    node.set((await this.mi_node.get().if_ixml_node$get_first_child()));\r\n    return node;\r\n  }\r\n  async if_ixml_node$get_children() {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_LIST\"});\r\n    val.set((await this.mi_node.get().if_ixml_node$get_children()));\r\n    return val;\r\n  }\r\n  async if_ixml_node$query_interface(INPUT) {\r\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_UNKNOWN\"});\r\n    let foo = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.foo) {foo.set(INPUT.foo);}\r\n    await this.mi_node.get().if_ixml_node$query_interface({foo: foo});\r\n    return rval;\r\n  }\r\n  async if_ixml_node$remove_node() {\r\n    await this.mi_node.get().if_ixml_node$remove_node();\r\n  }\r\n  async if_ixml_node$get_parent() {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    val.set((await this.mi_node.get().if_ixml_node$get_parent()));\r\n    return val;\r\n  }\r\n  async if_ixml_node$replace_child(INPUT) {\r\n    let new_child = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\r\n    let old_child = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.old_child) {old_child.set(INPUT.old_child);}\r\n    await this.mi_node.get().if_ixml_node$replace_child({new_child: new_child, old_child: old_child});\r\n  }\r\n  async if_ixml_node$get_name() {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    val.set((await this.mi_node.get().if_ixml_node$get_name()));\r\n    return val;\r\n  }\r\n  async if_ixml_node$get_depth() {\r\n    let val = new abap.types.Integer({qualifiedName: \"I\"});\r\n    val.set((await this.mi_node.get().if_ixml_node$get_depth()));\r\n    return val;\r\n  }\r\n  async if_ixml_node$is_leaf() {\r\n    let val = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\r\n    val.set((await this.mi_node.get().if_ixml_node$is_leaf()));\r\n    return val;\r\n  }\r\n  async if_ixml_node$get_namespace() {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    val.set((await this.mi_node.get().if_ixml_node$get_namespace()));\r\n    return val;\r\n  }\r\n  async if_ixml_node$get_value() {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    val.set((await this.mi_node.get().if_ixml_node$get_value()));\r\n    return val;\r\n  }\r\n  async if_ixml_node$get_type() {\r\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\r\n    val.set((await this.mi_node.get().if_ixml_node$get_type()));\r\n    return val;\r\n  }\r\n  async if_ixml_node$set_name(INPUT) {\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    await this.mi_node.get().if_ixml_node$set_name({name: name});\r\n  }\r\n  async if_ixml_node$remove_child(INPUT) {\r\n    let child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.child) {child.set(INPUT.child);}\r\n    await this.mi_node.get().if_ixml_node$remove_child({child: child});\r\n  }\r\n  async if_ixml_node$set_value(INPUT) {\r\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\r\n    await this.mi_node.get().if_ixml_node$set_value({value: value});\r\n  }\r\n  async if_ixml_document$set_encoding(INPUT) {\r\n    let encoding = new abap.types.ABAPObject();\r\n    if (INPUT && INPUT.encoding) {encoding = INPUT.encoding;}\r\n    return;\r\n  }\r\n  async if_ixml_document$set_standalone(INPUT) {\r\n    let standalone = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\r\n    if (INPUT && INPUT.standalone) {standalone = INPUT.standalone;}\r\n    return;\r\n  }\r\n  async if_ixml_document$set_namespace_prefix(INPUT) {\r\n    let prefix = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\r\n    return;\r\n  }\r\n  async if_ixml_document$append_child(INPUT) {\r\n    let new_child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\r\n    await this.if_ixml_node$append_child({new_child: new_child});\r\n  }\r\n  async if_ixml_document$get_first_child() {\r\n    let child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return child;\r\n  }\r\n  async if_ixml_document$create_attribute_ns(INPUT) {\r\n    let element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ATTRIBUTE\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let prefix = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return element;\r\n  }\r\n  async if_ixml_document$create_element_ns(INPUT) {\r\n    let element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let prefix = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\r\n    element.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\r\n    await element.get().if_ixml_node$set_name({name: name});\r\n    await element.get().if_ixml_node$set_namespace_prefix({val: prefix});\r\n    return element;\r\n  }\r\n  async if_ixml_document$create_element(INPUT) {\r\n    let element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    element.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\r\n    await element.get().if_ixml_node$set_name({name: name});\r\n    return element;\r\n  }\r\n  async if_ixml_document$create_iterator_filtered(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\r\n    let input = new abap.types.Character(4);\r\n    if (INPUT && INPUT.input) {input = INPUT.input;}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_document$create_filter_and(INPUT) {\r\n    let val = new abap.types.Character(4);\r\n    let filter1 = new abap.types.Character(4);\r\n    if (INPUT && INPUT.filter1) {filter1 = INPUT.filter1;}\r\n    let filter2 = new abap.types.Character(4);\r\n    if (INPUT && INPUT.filter2) {filter2 = INPUT.filter2;}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_document$create_iterator() {\r\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return rval;\r\n  }\r\n  async if_ixml_document$create_filter_node_type(INPUT) {\r\n    let val = new abap.types.Character(4);\r\n    let typ = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.typ) {typ.set(INPUT.typ);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_document$create_simple_element_ns(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let parent = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.parent) {parent.set(INPUT.parent);}\r\n    let prefix = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\r\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    val.set((await this.if_ixml_document$create_simple_element({name: name, parent: parent})));\r\n    await abap.statements.cast(li_node, val);\r\n    await li_node.get().if_ixml_node$set_namespace_prefix({val: prefix});\r\n    return val;\r\n  }\r\n  async if_ixml_document$create_filter_attribute(INPUT) {\r\n    let val = new abap.types.Character(4);\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_document$create_simple_element(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let parent = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.parent) {parent.set(INPUT.parent);}\r\n    val.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_({ii_parent: parent}));\r\n    await val.get().if_ixml_node$set_name({name: name});\r\n    return val;\r\n  }\r\n  async if_ixml_document$find_from_name(INPUT) {\r\n    let element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(35).set('todo, use find_from_name_ns instead')));\r\n    return element;\r\n  }\r\n  async if_ixml_document$find_from_name_ns(INPUT) {\r\n    let element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let depth = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\r\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    element.set((await this.mi_node.get().if_ixml_element$find_from_name_ns({name: name, depth: depth, namespace: new abap.types.Character(0).set('')})));\r\n    return element;\r\n  }\r\n  async if_ixml_document$find_from_path(INPUT) {\r\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let path = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.path) {path.set(INPUT.path);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_document$get_elements_by_tag_name_ns(INPUT) {\r\n    let val = new abap.types.Character(4);\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\r\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_document$get_elements_by_tag_name(INPUT) {\r\n    let val = new abap.types.Character(4);\r\n    let depth = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\r\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\r\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return val;\r\n  }\r\n  async if_ixml_document$get_root() {\r\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    node.set(this.mi_node);\r\n    return node;\r\n  }\r\n  async if_ixml_document$get_root_element() {\r\n    let root = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    root.set(this.mi_node);\r\n    return root;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_DOCUMENT'] = lcl_document;\r\nclass lcl_renderer {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_RENDERER\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mi_ostream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_OSTREAM\"});\r\n    this.mi_document = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_DOCUMENT\"});\r\n    let ostream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_OSTREAM\"});\r\n    if (INPUT && INPUT.ostream) {ostream.set(INPUT.ostream);}\r\n    let document = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_DOCUMENT\"});\r\n    if (INPUT && INPUT.document) {document.set(INPUT.document);}\r\n    this.mi_ostream.set(ostream);\r\n    this.mi_document.set(document);\r\n    return this;\r\n  }\r\n  async if_ixml_renderer$render() {\r\n    let li_root = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let li_element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\r\n    let li_children = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_LIST\"});\r\n    let li_iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\r\n    li_root.set((await this.mi_document.get().if_ixml_document$get_root_element()));\r\n    li_children.set((await li_root.get().if_ixml_element$get_children()));\r\n    li_iterator.set((await li_children.get().if_ixml_node_list$create_iterator()));\r\n    const indexBackup1 = abap.builtin.sy.get().index.get();\r\n    let unique104 = 1;\r\n    while (true) {\r\n      abap.builtin.sy.get().index.set(unique104++);\r\n      await abap.statements.cast(li_element, (await li_iterator.get().if_ixml_node_iterator$get_next()));\r\n      if (abap.compare.initial(li_element)) {\r\n        break;\r\n      }\r\n      await li_element.get().if_ixml_element$render({ostream: this.mi_ostream});\r\n    }\r\n    abap.builtin.sy.get().index.set(indexBackup1);\r\n  }\r\n  async if_ixml_renderer$set_normalizing(INPUT) {\r\n    let normal = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\r\n    if (INPUT && INPUT.normal) {normal = INPUT.normal;}\r\n    return;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_RENDERER'] = lcl_renderer;\r\nclass lcl_ostream {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_OSTREAM\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mv_string = new abap.types.String({qualifiedName: \"STRING\"});\r\n    return this;\r\n  }\r\n  async if_ixml_ostream$write_string(INPUT) {\r\n    let rval = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let string = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.string) {string.set(INPUT.string);}\r\n    this.mv_string.set(abap.operators.concat(this.mv_string,string));\r\n    return rval;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_OSTREAM'] = lcl_ostream;\r\nclass lcl_istream {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_ISTREAM\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mv_xml = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let iv_xml = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_xml) {iv_xml.set(INPUT.iv_xml);}\r\n    this.mv_xml.set(iv_xml);\r\n    return this;\r\n  }\r\n  async if_ixml_istream$close() {\r\n    return;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_ISTREAM'] = lcl_istream;\r\nclass lcl_stream_factory {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_STREAM_FACTORY\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    return this;\r\n  }\r\n  async if_ixml_stream_factory$create_ostream_cstring(INPUT) {\r\n    let stream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_OSTREAM\"});\r\n    let string = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.string) {string.set(INPUT.string);}\r\n    stream.set(await (new abap.Classes['CLAS-CL_IXML-LCL_OSTREAM']()).constructor_());\r\n    stream.get().mv_string = INPUT.string;\r\n    await stream.get().if_ixml_ostream$write_string({string: new abap.types.Character(39).set('<?xml version=\"1.0\" encoding=\"utf-16\"?>')});\r\n    return stream;\r\n  }\r\n  async if_ixml_stream_factory$create_ostream_xstring(INPUT) {\r\n    let stream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_OSTREAM\"});\r\n    let string = new abap.types.XString({qualifiedName: \"XSTRING\"});\r\n    if (INPUT && INPUT.string) {string.set(INPUT.string);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return stream;\r\n  }\r\n  async if_ixml_stream_factory$create_istream_xstring(INPUT) {\r\n    let stream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ISTREAM\"});\r\n    let xml = new abap.types.XString({qualifiedName: \"XSTRING\"});\r\n    if (INPUT && INPUT.xml) {xml.set(INPUT.xml);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return stream;\r\n  }\r\n  async if_ixml_stream_factory$create_istream_string(INPUT) {\r\n    let stream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ISTREAM\"});\r\n    let xml = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.xml) {xml.set(INPUT.xml);}\r\n    stream.set(await (new abap.Classes['CLAS-CL_IXML-LCL_ISTREAM']()).constructor_({iv_xml: xml}));\r\n    return stream;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_STREAM_FACTORY'] = lcl_stream_factory;\r\nclass lcl_parser {\r\n  static INTERNAL_TYPE = 'CLAS';\r\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_PARSER\"];\r\n  async constructor_(INPUT) {\r\n    this.me = new abap.types.ABAPObject();\r\n    this.me.set(this);\r\n    this.mi_istream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ISTREAM\"});\r\n    this.mi_document = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_DOCUMENT\"});\r\n    this.lc_regex_tag = lcl_parser.lc_regex_tag;\r\n    this.lc_regex_attr = lcl_parser.lc_regex_attr;\r\n    let istream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ISTREAM\"});\r\n    if (INPUT && INPUT.istream) {istream.set(INPUT.istream);}\r\n    let document = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_DOCUMENT\"});\r\n    if (INPUT && INPUT.document) {document.set(INPUT.document);}\r\n    this.mi_istream.set(istream);\r\n    this.mi_document.set(document);\r\n    return this;\r\n  }\r\n  async if_ixml_parser$set_validating(INPUT) {\r\n    let rval = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\r\n    let mode = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (INPUT && INPUT.mode) {mode.set(INPUT.mode);}\r\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\r\n    return rval;\r\n  }\r\n  async if_ixml_parser$parse() {\r\n    let subrc = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let lv_xml = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let lv_offset = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let lv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let lv_name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let lv_namespace = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let ls_match = new abap.types.Structure({\"line\": new abap.types.Integer(), \"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer(), \"submatches\": new abap.types.Table(new abap.types.Structure({\"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer()}, \"SUBMATCH_RESULT\"), {\"withHeader\":false}, \"SUBMATCH_RESULT_TAB\")}, \"MATCH_RESULT\");\r\n    let ls_submatch = new abap.types.Structure({\"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer()}, \"SUBMATCH_RESULT\");\r\n    let lo_parent = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\r\n    let lo_node = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\r\n    await abap.statements.cast(lo_parent, (await this.mi_document.get().if_ixml_document$get_root()));\r\n    lv_xml.set(this.mi_istream.get().mv_xml);\r\n    abap.statements.replace({target: lv_xml, all: true, with: new abap.types.String().set(``), of: new abap.types.String().set(`\\n`)});\r\n    const indexBackup1 = abap.builtin.sy.get().index.get();\r\n    let unique105 = 1;\r\n    while (abap.compare.initial(lv_xml) === false) {\r\n      abap.builtin.sy.get().index.set(unique105++);\r\n      abap.statements.clear(lo_node);\r\n      if (abap.compare.cp(lv_xml, new abap.types.Character(7).set('<?xml *'))) {\r\n        abap.statements.find(lv_xml, {find: new abap.types.Character(2).set('?>'), first: true, offset: lv_offset});\r\n        abap.statements.assert(abap.compare.gt(lv_offset, new abap.types.Integer().set(0)));\r\n        lv_offset.set(abap.operators.add(lv_offset,new abap.types.Integer().set(2)));\r\n      } else if (abap.compare.cp(lv_xml, new abap.types.Character(2).set('<*'))) {\r\n        abap.statements.find(lv_xml, {regex: lcl_parser.lc_regex_tag, first: true, results: ls_match});\r\n        abap.statements.assert(abap.compare.eq(ls_match.get().offset, new abap.types.Integer().set(0)));\r\n        abap.statements.readTable(ls_match.get().submatches,{index: new abap.types.Integer().set(1),into: ls_submatch});\r\n        abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0)));\r\n        lv_name.set(lv_xml.getOffset({offset: ls_submatch.get().offset, length: ls_submatch.get().length}));\r\n        if (abap.compare.cp(lv_xml, new abap.types.Character(3).set('</*'))) {\r\n          await abap.statements.cast(lo_parent, (await lo_parent.get().if_ixml_node$get_parent()));\r\n        } else {\r\n          lo_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_({ii_parent: lo_parent}));\r\n          if (abap.compare.ca(lv_name, new abap.types.Character(1).set(':'))) {\r\n            abap.statements.split({source: lv_name, at: new abap.types.Character(1).set(':'), targets: [lv_namespace,lv_name]});\r\n            await lo_node.get().if_ixml_node$set_namespace_prefix({val: lv_namespace});\r\n          }\r\n          await lo_node.get().if_ixml_node$set_name({name: lv_name});\r\n          lo_parent.set(lo_node);\r\n        }\r\n        await this.parse_attributes({ii_node: lo_node, iv_xml: lv_xml, is_match: ls_match});\r\n        lv_offset.set(ls_match.get().length);\r\n      } else {\r\n        abap.statements.find(lv_xml, {find: new abap.types.Character(1).set('<'), first: true, offset: lv_offset});\r\n        lv_value.set(lv_xml.getOffset({length: lv_offset}));\r\n        lo_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_({ii_parent: lo_parent}));\r\n        await lo_node.get().if_ixml_node$set_name({name: new abap.types.Character(5).set('#text')});\r\n        await lo_node.get().if_ixml_node$set_value({value: (await abap.Classes['CLAS-CL_IXML-LCL_ESCAPE'].unescape_value({iv_value: lv_value}))});\r\n      }\r\n      lv_xml.set(lv_xml.getOffset({offset: lv_offset}));\r\n      abap.statements.condense(lv_xml, {nogaps: false});\r\n    }\r\n    abap.builtin.sy.get().index.set(indexBackup1);\r\n    return subrc;\r\n  }\r\n  async parse_attributes(INPUT) {\r\n    let ii_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    if (INPUT && INPUT.ii_node) {ii_node.set(INPUT.ii_node);}\r\n    let iv_xml = new abap.types.String({qualifiedName: \"STRING\"});\r\n    if (INPUT && INPUT.iv_xml) {iv_xml.set(INPUT.iv_xml);}\r\n    let is_match = new abap.types.Structure({\"line\": new abap.types.Integer(), \"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer(), \"submatches\": new abap.types.Table(new abap.types.Structure({\"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer()}, \"SUBMATCH_RESULT\"), {\"withHeader\":false}, \"SUBMATCH_RESULT_TAB\")}, \"MATCH_RESULT\");\r\n    if (INPUT && INPUT.is_match) {is_match.set(INPUT.is_match);}\r\n    let ls_submatch = new abap.types.Structure({\"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer()}, \"SUBMATCH_RESULT\");\r\n    let lv_name = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let lv_value = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let lv_xml = new abap.types.String({qualifiedName: \"STRING\"});\r\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\r\n    let lv_offset = new abap.types.Integer({qualifiedName: \"I\"});\r\n    let lv_length = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (abap.compare.eq(abap.builtin.lines({val: is_match.get().submatches}), new abap.types.Integer().set(1))) {\r\n      return;\r\n    }\r\n    lv_xml.set(iv_xml.getOffset({length: is_match.get().length}));\r\n    const indexBackup1 = abap.builtin.sy.get().index.get();\r\n    let unique106 = 1;\r\n    while (true) {\r\n      abap.builtin.sy.get().index.set(unique106++);\r\n      abap.statements.find(lv_xml, {regex: lcl_parser.lc_regex_attr, first: true, offset: lv_offset, length: lv_length, submatches: [lv_name,lv_value]});\r\n      if (abap.compare.ne(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0))) {\r\n        abap.builtin.sy.get().index.set(indexBackup1);\r\n        return;\r\n      }\r\n      li_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\r\n      await li_node.get().if_ixml_node$set_name({name: lv_name});\r\n      await li_node.get().if_ixml_node$set_value({value: lv_value});\r\n      await (await ii_node.get().if_ixml_node$get_attributes()).get().if_ixml_named_node_map$set_named_item_ns({node: li_node});\r\n      lv_offset.set(abap.operators.add(lv_offset,lv_length));\r\n      lv_xml.set(lv_xml.getOffset({offset: lv_offset}));\r\n    }\r\n    abap.builtin.sy.get().index.set(indexBackup1);\r\n  }\r\n  async if_ixml_parser$set_normalizing(INPUT) {\r\n    let normal = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\r\n    if (INPUT && INPUT.normal) {normal = INPUT.normal;}\r\n    return;\r\n  }\r\n  async if_ixml_parser$num_errors() {\r\n    let errors = new abap.types.Integer({qualifiedName: \"I\"});\r\n    return errors;\r\n    return errors;\r\n  }\r\n  async if_ixml_parser$add_strip_space_element() {\r\n    return;\r\n  }\r\n  async if_ixml_parser$get_error(INPUT) {\r\n    let error = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_PARSE_ERROR\"});\r\n    let index = new abap.types.Integer({qualifiedName: \"I\"});\r\n    if (INPUT && INPUT.index) {index.set(INPUT.index);}\r\n    return error;\r\n    return error;\r\n  }\r\n}\r\nabap.Classes['CLAS-CL_IXML-LCL_PARSER'] = lcl_parser;\r\nlcl_parser.lc_regex_tag = new abap.types.String({qualifiedName: \"STRING\"});\r\nlcl_parser.lc_regex_tag.set('<\\\\/?([\\\\w:]+)( [\\\\w:]+=\"[\\\\w\\\\.:\\\\/]+\")*>');\r\nlcl_parser.lc_regex_attr = new abap.types.String({qualifiedName: \"STRING\"});\r\nlcl_parser.lc_regex_attr.set('([\\\\w:]+)=\"([\\\\w\\\\.:\\\\/]+)\"');\r\n\r\n//# sourceMappingURL=cl_ixml.clas.locals.mjs.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://aff-web/./output_abap/cl_ixml.clas.locals.mjs?");

/***/ })

}]);